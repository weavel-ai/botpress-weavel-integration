{
  "version": 3,
  "sources": ["../../src/utils/tunnel-utils.ts"],
  "sourcesContent": ["import { TunnelTail, ClientCloseEvent, ClientErrorEvent } from '@bpinternal/tunnel'\nimport { Logger } from '../logger'\nimport { EventEmitter } from './event-emitter'\n\nexport type ReconnectionTriggerEvent =\n  | {\n      type: 'init'\n      ev: null\n    }\n  | {\n      type: 'error'\n      ev: ClientErrorEvent\n    }\n  | {\n      type: 'close'\n      ev: ClientCloseEvent\n    }\n\nexport type ReconnectedEvent = {\n  tunnel: TunnelTail\n  ev: ReconnectionTriggerEvent\n}\n\nexport class ReconnectionFailedError extends Error {\n  public constructor(public readonly event: ReconnectionTriggerEvent) {\n    const reason = ReconnectionFailedError._reason(event)\n    super(`Reconnection failed: ${reason}`)\n  }\n\n  private static _reason(event: ReconnectionTriggerEvent): string {\n    if (event.type === 'error') {\n      return 'error'\n    }\n\n    if (event.type === 'close') {\n      return `${event.ev.code} ${event.ev.reason}`\n    }\n\n    return 'init'\n  }\n}\n\nexport class TunnelSupervisor {\n  private _tunnel?: TunnelTail\n  private _closed = false\n  private _started = false\n\n  public readonly events = new EventEmitter<{\n    connectionFailed: ReconnectionTriggerEvent\n    manuallyClosed: null\n    connected: {\n      tunnel: TunnelTail\n      ev: ReconnectionTriggerEvent\n    }\n  }>()\n\n  constructor(private _tunnelUrl: string, private _tunnelId: string, private _logger: Logger) {}\n\n  public async start(): Promise<void> {\n    if (this._closed) {\n      throw new Error('Cannot start: Tunnel is closed')\n    }\n    if (this._started) {\n      throw new Error('Cannot start: Tunnel is already started')\n    }\n\n    this._started = true\n    const tunnel = await this._reconnect({ type: 'init', ev: null })\n    this._tunnel = tunnel\n  }\n\n  public get closed(): boolean {\n    return this._closed\n  }\n\n  /**\n   * @returns Promise that rejects when a reconnection attempt fails and resolves when the tunnel is closed manually\n   */\n  public async wait(): Promise<void> {\n    if (this._closed) {\n      throw new Error('Cannot wait: Tunnel is closed')\n    }\n\n    return new Promise((resolve, reject) => {\n      this.events.on('connectionFailed', (ev) => {\n        reject(new ReconnectionFailedError(ev))\n      })\n\n      this.events.on('manuallyClosed', () => {\n        resolve()\n      })\n    })\n  }\n\n  public close(): void {\n    if (this._closed) {\n      return\n    }\n\n    this._closed = true\n    this._tunnel?.close()\n    this.events.emit('manuallyClosed', null)\n  }\n\n  private _reconnectSync(ev: ReconnectionTriggerEvent): void {\n    void this._reconnect(ev)\n      .then((t) => {\n        this._tunnel = t\n      })\n      .catch(() => this.events.emit('connectionFailed', ev))\n  }\n\n  private async _reconnect(ev: ReconnectionTriggerEvent): Promise<TunnelTail> {\n    const newTunnel = async () => {\n      const tunnel = await TunnelTail.new(this._tunnelUrl, this._tunnelId)\n      this._registerListeners(tunnel)\n      this.events.emit('connected', { tunnel, ev })\n      return tunnel\n    }\n\n    if (ev.type === 'init') {\n      // skip logging on the first connection attempt\n      return newTunnel()\n    }\n\n    const line = this._logger.line()\n    line.started('Reconnecting tunnel...')\n    const tunnel = await newTunnel()\n    line.success('Reconnected')\n    line.commit()\n    return tunnel\n  }\n\n  private _registerListeners(tunnel: TunnelTail) {\n    tunnel.events.on('error', ({ target, type }) => {\n      this._logger.error(`Tunnel error: ${type}`)\n      this._reconnectSync({ type: 'error', ev: { target, type } })\n    })\n    tunnel.events.on('close', ({ code, reason, target, type, wasClean }) => {\n      this._logger.error(`Tunnel closed: ${code} ${reason}`)\n      this._reconnectSync({ type: 'close', ev: { code, reason, target, type, wasClean } })\n    })\n  }\n}\n"],
  "mappings": "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",
  "names": ["tunnel"]
}
