{
  "version": 3,
  "sources": ["../../src/utils/cache-utils.ts"],
  "sourcesContent": ["import fs from 'fs'\nimport pathlib from 'path'\n\nexport class FSKeyValueCache<T extends Object> {\n  private _initialized = false\n\n  constructor(private _filepath: string) {}\n\n  public async init(): Promise<void> {\n    if (this._initialized) {\n      return\n    }\n    const dirname = pathlib.dirname(this._filepath)\n    if (!fs.existsSync(dirname)) {\n      await fs.promises.mkdir(dirname, { recursive: true })\n    }\n    if (!fs.existsSync(this._filepath)) {\n      await this._writeJSON(this._filepath, {})\n    }\n    this._initialized = true\n  }\n\n  public async sync<K extends keyof T>(\n    key: K,\n    value: T[K] | undefined,\n    prompt: (initial?: T[K]) => Promise<T[K]>\n  ): Promise<T[K]> {\n    await this.init()\n    if (value) {\n      await this.set(key, value)\n      return value\n    }\n    const data = await this.get(key)\n    const newValue = await prompt(data)\n    await this.set(key, newValue)\n    return newValue\n  }\n\n  public async has<K extends keyof T>(key: K): Promise<boolean> {\n    await this.init()\n    const data = await this._readJSON(this._filepath)\n    return data[key] !== undefined\n  }\n\n  public async get<K extends keyof T>(key: K): Promise<T[K] | undefined> {\n    await this.init()\n    const data: T = await this._readJSON(this._filepath)\n    return data[key]\n  }\n\n  public async set<K extends keyof T>(key: K, value: T[K]): Promise<void> {\n    await this.init()\n    const data: T = await this._readJSON(this._filepath)\n    data[key] = value\n    return this._writeJSON(this._filepath, data)\n  }\n\n  public async rm<K extends keyof T>(key: K): Promise<void> {\n    await this.init()\n    const data: T = await this._readJSON(this._filepath)\n    delete data[key]\n    return this._writeJSON(this._filepath, data)\n  }\n\n  public async clear(): Promise<void> {\n    await this.init()\n    return this._writeJSON(this._filepath, {})\n  }\n\n  private _writeJSON = (filepath: string, data: any) => {\n    const fileContent = JSON.stringify(data, null, 2)\n    return fs.promises.writeFile(filepath, fileContent)\n  }\n\n  private _readJSON = async (filepath: string) => {\n    const fileContent = await fs.promises.readFile(filepath, 'utf8')\n    return JSON.parse(fileContent)\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAe;AACf,kBAAoB;AAEb,MAAM,gBAAkC;AAAA,EAG7C,YAAoB,WAAmB;AAAnB;AAAA,EAAoB;AAAA,EAFhC,eAAe;AAAA,EAIvB,MAAa,OAAsB;AACjC,QAAI,KAAK,cAAc;AACrB;AAAA,IACF;AACA,UAAM,UAAU,YAAAA,QAAQ,QAAQ,KAAK,SAAS;AAC9C,QAAI,CAAC,UAAAC,QAAG,WAAW,OAAO,GAAG;AAC3B,YAAM,UAAAA,QAAG,SAAS,MAAM,SAAS,EAAE,WAAW,KAAK,CAAC;AAAA,IACtD;AACA,QAAI,CAAC,UAAAA,QAAG,WAAW,KAAK,SAAS,GAAG;AAClC,YAAM,KAAK,WAAW,KAAK,WAAW,CAAC,CAAC;AAAA,IAC1C;AACA,SAAK,eAAe;AAAA,EACtB;AAAA,EAEA,MAAa,KACX,KACA,OACA,QACe;AACf,UAAM,KAAK,KAAK;AAChB,QAAI,OAAO;AACT,YAAM,KAAK,IAAI,KAAK,KAAK;AACzB,aAAO;AAAA,IACT;AACA,UAAM,OAAO,MAAM,KAAK,IAAI,GAAG;AAC/B,UAAM,WAAW,MAAM,OAAO,IAAI;AAClC,UAAM,KAAK,IAAI,KAAK,QAAQ;AAC5B,WAAO;AAAA,EACT;AAAA,EAEA,MAAa,IAAuB,KAA0B;AAC5D,UAAM,KAAK,KAAK;AAChB,UAAM,OAAO,MAAM,KAAK,UAAU,KAAK,SAAS;AAChD,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EAEA,MAAa,IAAuB,KAAmC;AACrE,UAAM,KAAK,KAAK;AAChB,UAAM,OAAU,MAAM,KAAK,UAAU,KAAK,SAAS;AACnD,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAa,IAAuB,KAAQ,OAA4B;AACtE,UAAM,KAAK,KAAK;AAChB,UAAM,OAAU,MAAM,KAAK,UAAU,KAAK,SAAS;AACnD,SAAK,OAAO;AACZ,WAAO,KAAK,WAAW,KAAK,WAAW,IAAI;AAAA,EAC7C;AAAA,EAEA,MAAa,GAAsB,KAAuB;AACxD,UAAM,KAAK,KAAK;AAChB,UAAM,OAAU,MAAM,KAAK,UAAU,KAAK,SAAS;AACnD,WAAO,KAAK;AACZ,WAAO,KAAK,WAAW,KAAK,WAAW,IAAI;AAAA,EAC7C;AAAA,EAEA,MAAa,QAAuB;AAClC,UAAM,KAAK,KAAK;AAChB,WAAO,KAAK,WAAW,KAAK,WAAW,CAAC,CAAC;AAAA,EAC3C;AAAA,EAEQ,aAAa,CAAC,UAAkB,SAAc;AACpD,UAAM,cAAc,KAAK,UAAU,MAAM,MAAM,CAAC;AAChD,WAAO,UAAAA,QAAG,SAAS,UAAU,UAAU,WAAW;AAAA,EACpD;AAAA,EAEQ,YAAY,OAAO,aAAqB;AAC9C,UAAM,cAAc,MAAM,UAAAA,QAAG,SAAS,SAAS,UAAU,MAAM;AAC/D,WAAO,KAAK,MAAM,WAAW;AAAA,EAC/B;AACF;",
  "names": ["pathlib", "fs"]
}
