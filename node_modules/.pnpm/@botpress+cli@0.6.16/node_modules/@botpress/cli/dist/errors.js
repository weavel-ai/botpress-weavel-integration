"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var errors_exports = {};
__export(errors_exports, {
  BotpressCLIError: () => BotpressCLIError,
  ExclusiveBotFeatureError: () => ExclusiveBotFeatureError,
  ExclusiveIntegrationFeatureError: () => ExclusiveIntegrationFeatureError,
  HTTPError: () => HTTPError,
  InvalidIntegrationReferenceError: () => InvalidIntegrationReferenceError,
  NoBotsFoundError: () => NoBotsFoundError,
  NoBundleFoundError: () => NoBundleFoundError,
  NoWorkspacesFoundError: () => NoWorkspacesFoundError,
  NotLoggedInError: () => NotLoggedInError,
  ParamRequiredError: () => ParamRequiredError
});
module.exports = __toCommonJS(errors_exports);
var import_client = require("@botpress/client");
var import_axios = __toESM(require("axios"));
var import_verror = require("verror");
var consts = __toESM(require("./consts"));
const isKnownApiError = (e) => (0, import_client.isApiError)(e) && !(e instanceof import_client.UnknownError);
class BotpressCLIError extends import_verror.VError {
  static wrap(thrown, message) {
    const err = BotpressCLIError.map(thrown);
    return new BotpressCLIError(err, message ?? "");
  }
  static map(thrown) {
    if (thrown instanceof BotpressCLIError) {
      return thrown;
    }
    if (thrown instanceof import_client.UnknownError) {
      const inst = new HTTPError(500, "An unknown error has occurred.");
      inst.debug = thrown.message;
      return inst;
    }
    if (isKnownApiError(thrown)) {
      return HTTPError.fromApi(thrown);
    }
    if (import_axios.default.isAxiosError(thrown)) {
      return HTTPError.fromAxios(thrown);
    }
    if (thrown instanceof Error) {
      const { message } = thrown;
      return new BotpressCLIError(message);
    }
    return new BotpressCLIError(`${thrown}`);
  }
  _debug;
  constructor(first, second) {
    if (typeof first === "string") {
      super(first);
      this._debug = [];
      return;
    }
    super(first, second);
    this._debug = [...first._debug];
  }
  set debug(msg) {
    this._debug.push(msg);
  }
  get debug() {
    const dbgMsgs = this._debug.filter((s) => s.length);
    if (!dbgMsgs.length) {
      return "";
    }
    return "Error: \n" + dbgMsgs.map((s) => `  ${s}`).join("\n");
  }
}
class ExclusiveBotFeatureError extends BotpressCLIError {
  constructor() {
    const message = "This feature is only available for bots. This project is an integration";
    super(message);
  }
}
class ExclusiveIntegrationFeatureError extends BotpressCLIError {
  constructor() {
    const message = "This feature is only available for integration. This project is a bot";
    super(message);
  }
}
class HTTPError extends BotpressCLIError {
  constructor(status, message) {
    super(message);
    this.status = status;
  }
  static fromAxios(e) {
    const message = this._axiosMsg(e);
    return new HTTPError(e.response?.status, message);
  }
  static fromApi(e) {
    const { message, code } = e;
    return new HTTPError(code, message);
  }
  static _axiosMsg(e) {
    let message = e.message;
    if (e.response?.statusText) {
      message += `
  ${e.response?.statusText}`;
    }
    if (e.response?.status && e.request?.method && e.request?.path) {
      message += `
  (${e.response?.status}) ${e.request.method} ${e.request.path}`;
    }
    if (e.response?.data?.message) {
      message += `
  ${e.response?.data?.message}`;
    }
    return message;
  }
}
class NoBundleFoundError extends BotpressCLIError {
  constructor() {
    const message = "No bundle found. Please run `bp bundle` first.";
    super(message);
  }
}
class NoBotsFoundError extends BotpressCLIError {
  constructor() {
    const message = `No Bot found in your Workspace. Please create one first at ${consts.defaultBotpressAppUrl}.`;
    super(message);
  }
}
class NoWorkspacesFoundError extends BotpressCLIError {
  constructor() {
    const message = "No Workspace found. Please create one first.";
    super(message);
  }
}
class NotLoggedInError extends BotpressCLIError {
  constructor() {
    const message = "Not logged in. Please run `bp login` first.";
    super(message);
  }
}
class ParamRequiredError extends BotpressCLIError {
  constructor(param) {
    const message = `${param} is required.`;
    super(message);
  }
}
class InvalidIntegrationReferenceError extends BotpressCLIError {
  constructor(ref) {
    const message = `Invalid integration reference "${ref}".`;
    super(message);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BotpressCLIError,
  ExclusiveBotFeatureError,
  ExclusiveIntegrationFeatureError,
  HTTPError,
  InvalidIntegrationReferenceError,
  NoBotsFoundError,
  NoBundleFoundError,
  NoWorkspacesFoundError,
  NotLoggedInError,
  ParamRequiredError
});
//# sourceMappingURL=errors.js.map
