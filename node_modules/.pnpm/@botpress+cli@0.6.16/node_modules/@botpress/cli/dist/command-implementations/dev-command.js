"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var dev_command_exports = {};
__export(dev_command_exports, {
  DevCommand: () => DevCommand
});
module.exports = __toCommonJS(dev_command_exports);
var import_axios = __toESM(require("axios"));
var import_chalk = __toESM(require("chalk"));
var pathlib = __toESM(require("path"));
var uuid = __toESM(require("uuid"));
var import_bot_body = require("../api/bot-body");
var import_integration_body = require("../api/integration-body");
var errors = __toESM(require("../errors"));
var utils = __toESM(require("../utils"));
var import_worker = require("../worker");
var import_build_command = require("./build-command");
var import_project_command = require("./project-command");
const DEFAULT_BOT_PORT = 8075;
const DEFAULT_INTEGRATION_PORT = 8076;
const TUNNEL_HELLO_INTERVAL = 5e3;
class DevCommand extends import_project_command.ProjectCommand {
  _initialDef = void 0;
  async run() {
    this.logger.warn("This command is experimental and subject to breaking changes without notice.");
    const api = await this.ensureLoginAndCreateClient(this.argv);
    this._initialDef = await this.readIntegrationDefinitionFromFS();
    let env = {
      ...process.env,
      BP_API_URL: api.url,
      BP_TOKEN: api.token
    };
    let defaultPort = DEFAULT_BOT_PORT;
    if (this._initialDef) {
      defaultPort = DEFAULT_INTEGRATION_PORT;
      const secretEnvVariables = await this.promptSecrets(this._initialDef, this.argv, { formatEnv: true });
      const nonNullSecretEnvVariables = utils.records.filterValues(secretEnvVariables, utils.guards.is.notNull);
      env = { ...env, ...nonNullSecretEnvVariables };
    }
    const port = this.argv.port ?? defaultPort;
    const urlParseResult = utils.url.parse(this.argv.tunnelUrl);
    if (urlParseResult.status === "error") {
      throw new errors.BotpressCLIError(`Invalid tunnel URL: ${urlParseResult.error}`);
    }
    const tunnelId = uuid.v4();
    const { url: parsedTunnelUrl } = urlParseResult;
    const isSecured = parsedTunnelUrl.protocol === "https" || parsedTunnelUrl.protocol === "wss";
    const wsTunnelUrl = utils.url.format({ ...parsedTunnelUrl, protocol: isSecured ? "wss" : "ws" });
    const httpTunnelUrl = utils.url.format({
      ...parsedTunnelUrl,
      protocol: isSecured ? "https" : "http",
      path: `/${tunnelId}`
    });
    let worker = void 0;
    const supervisor = new utils.tunnel.TunnelSupervisor(wsTunnelUrl, tunnelId, this.logger);
    supervisor.events.on("connected", ({ tunnel }) => {
      const timer = setInterval(() => {
        if (tunnel.closed) {
          return handleClose();
        }
        tunnel.hello();
      }, TUNNEL_HELLO_INTERVAL);
      const handleClose = () => clearInterval(timer);
      tunnel.events.on("close", handleClose);
      tunnel.events.on("request", (req) => {
        if (!worker) {
          this.logger.debug("Worker not ready yet, ignoring request");
          tunnel.send({ requestId: req.id, status: 503, body: "Worker not ready yet" });
          return;
        }
        void this._forwardTunnelRequest(`http://localhost:${port}`, req).then((res) => {
          tunnel.send(res);
        }).catch((thrown) => {
          const err = errors.BotpressCLIError.wrap(thrown, "An error occurred while handling request");
          this.logger.error(err.message);
          tunnel.send({
            requestId: req.id,
            status: 500,
            body: err.message
          });
        });
      });
    });
    supervisor.events.on("manuallyClosed", () => {
      this.logger.debug("Tunnel manually closed");
    });
    await supervisor.start();
    await this._runBuild();
    await this._deploy(api, httpTunnelUrl);
    worker = await this._spawnWorker(env, port);
    try {
      const watcher = await utils.filewatcher.FileWatcher.watch(
        this.argv.workDir,
        async (events) => {
          if (!worker) {
            this.logger.debug("Worker not ready yet, ignoring file change event");
            return;
          }
          const typescriptEvents = events.filter((e) => pathlib.extname(e.path) === ".ts");
          if (typescriptEvents.length === 0) {
            return;
          }
          this.logger.log("Changes detected, rebuilding");
          await this._restart(api, worker, httpTunnelUrl);
        },
        {
          ignore: [this.projectPaths.abs.outDir]
        }
      );
      await Promise.race([worker.wait(), watcher.wait(), supervisor.wait()]);
      if (worker.running) {
        await worker.kill();
      }
      await watcher.close();
      supervisor.close();
    } catch (thrown) {
      throw errors.BotpressCLIError.wrap(thrown, "An error occurred while running the dev server");
    } finally {
      if (worker.running) {
        await worker.kill();
      }
    }
  }
  _restart = async (api, worker, tunnelUrl) => {
    try {
      await this._runBuild();
    } catch (thrown) {
      const error = errors.BotpressCLIError.wrap(thrown, "Build failed");
      this.logger.error(error.message);
      return;
    }
    await this._deploy(api, tunnelUrl);
    await worker.reload();
  };
  _deploy = async (api, tunnelUrl) => {
    const integrationDef = await this.readIntegrationDefinitionFromFS();
    if (integrationDef) {
      this._checkSecrets(integrationDef);
      await this._deployDevIntegration(api, tunnelUrl, integrationDef);
    } else {
      await this._deployDevBot(api, tunnelUrl);
    }
  };
  _checkSecrets(integrationDef) {
    const initialSecrets = this._initialDef?.secrets ?? {};
    const currentSecrets = integrationDef.secrets ?? {};
    const newSecrets = Object.keys(currentSecrets).filter((s) => !initialSecrets[s]);
    if (newSecrets.length > 0) {
      throw new errors.BotpressCLIError("Secrets were added while the server was running. A restart is required.");
    }
  }
  _spawnWorker = async (env, port) => {
    const outfile = this.projectPaths.abs.outFile;
    const importPath = utils.path.toUnix(outfile);
    const requireFrom = utils.path.rmExtension(importPath);
    const code = `require('${requireFrom}').default.start(${port})`;
    const worker = await import_worker.Worker.spawn(
      {
        type: "code",
        code,
        env
      },
      this.logger
    ).catch((thrown) => {
      throw errors.BotpressCLIError.wrap(thrown, "Could not start dev worker");
    });
    return worker;
  };
  _runBuild() {
    return new import_build_command.BuildCommand(this.api, this.prompt, this.logger, this.argv).run();
  }
  async _deployDevIntegration(api, externalUrl, integrationDef) {
    const devId = await this.projectCache.get("devId");
    let integration = void 0;
    if (devId) {
      const resp = await api.client.getIntegration({ id: devId }).catch(async (thrown) => {
        const err = errors.BotpressCLIError.wrap(thrown, `Could not find existing dev integration with id "${devId}"`);
        this.logger.warn(err.message);
        return { integration: void 0 };
      });
      if (resp.integration?.dev) {
        integration = resp.integration;
      } else {
        await this.projectCache.rm("devId");
      }
    }
    const line = this.logger.line();
    line.started(`Deploying dev integration ${import_chalk.default.bold(integrationDef.name)}...`);
    const createIntegrationBody = {
      ...(0, import_integration_body.prepareCreateIntegrationBody)(integrationDef),
      url: externalUrl
    };
    if (integration) {
      const updateIntegrationBody = (0, import_integration_body.prepareUpdateIntegrationBody)(
        { ...createIntegrationBody, id: integration.id },
        integration
      );
      const resp = await api.client.updateIntegration(updateIntegrationBody).catch((thrown) => {
        throw errors.BotpressCLIError.wrap(thrown, `Could not update dev integration "${integrationDef.name}"`);
      });
      integration = resp.integration;
    } else {
      const resp = await api.client.createIntegration({ ...createIntegrationBody, dev: true }).catch((thrown) => {
        throw errors.BotpressCLIError.wrap(thrown, `Could not deploy dev integration "${integrationDef.name}"`);
      });
      integration = resp.integration;
    }
    line.success(`Dev Integration deployed with id "${integration.id}"`);
    line.commit();
    await this.projectCache.set("devId", integration.id);
  }
  async _deployDevBot(api, externalUrl) {
    const devId = await this.projectCache.get("devId");
    let bot = void 0;
    if (devId) {
      const resp = await api.client.getBot({ id: devId }).catch(async (thrown) => {
        const err = errors.BotpressCLIError.wrap(thrown, `Could not find existing dev bot with id "${devId}"`);
        this.logger.warn(err.message);
        return { bot: void 0 };
      });
      if (resp.bot?.dev) {
        bot = resp.bot;
      } else {
        await this.projectCache.rm("devId");
      }
    }
    if (!bot) {
      const createLine = this.logger.line();
      createLine.started("Creating dev bot...");
      const resp = await api.client.createBot({
        dev: true,
        url: externalUrl
      }).catch((thrown) => {
        throw errors.BotpressCLIError.wrap(thrown, "Could not deploy dev bot");
      });
      bot = resp.bot;
      createLine.success(`Dev Bot created with id "${bot.id}"`);
      createLine.commit();
      await this.projectCache.set("devId", bot.id);
    }
    const outfile = this.projectPaths.abs.outFile;
    const { default: botImpl } = utils.require.requireJsFile(outfile);
    const updateLine = this.logger.line();
    updateLine.started("Deploying dev bot...");
    const integrationInstances = await this.fetchBotIntegrationInstances(botImpl, api);
    const updateBotBody = (0, import_bot_body.prepareUpdateBotBody)(
      {
        ...(0, import_bot_body.prepareCreateBotBody)(botImpl),
        id: bot.id,
        url: externalUrl,
        integrations: integrationInstances
      },
      bot
    );
    const { bot: updatedBot } = await api.client.updateBot(updateBotBody).catch((thrown) => {
      throw errors.BotpressCLIError.wrap(thrown, "Could not deploy dev bot");
    });
    updateLine.success(`Dev Bot deployed with id "${updatedBot.id}"`);
    updateLine.commit();
    this.displayWebhookUrls(updatedBot);
  }
  _forwardTunnelRequest = async (baseUrl, request) => {
    const axiosConfig = {
      method: request.method,
      url: this._formatLocalUrl(baseUrl, request),
      headers: request.headers,
      data: request.body,
      responseType: "text",
      validateStatus: () => true
    };
    this.logger.debug(`Forwarding request to ${axiosConfig.url}`);
    const response = await (0, import_axios.default)(axiosConfig);
    this.logger.debug("Sending back response up the tunnel");
    return {
      requestId: request.id,
      status: response.status,
      headers: this._getHeaders(response.headers),
      body: response.data
    };
  };
  _formatLocalUrl = (baseUrl, req) => {
    if (req.query) {
      return `${baseUrl}${req.path}?${req.query}`;
    }
    return `${baseUrl}${req.path}`;
  };
  _getHeaders = (res) => {
    const headers = {};
    for (const key in res) {
      if (typeof res[key] === "string" || typeof res[key] === "number") {
        headers[key] = res[key];
      }
    }
    return headers;
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DevCommand
});
//# sourceMappingURL=dev-command.js.map
