"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var project_command_exports = {};
__export(project_command_exports, {
  ProjectCommand: () => ProjectCommand
});
module.exports = __toCommonJS(project_command_exports);
var import_bluebird = __toESM(require("bluebird"));
var import_chalk = __toESM(require("chalk"));
var import_fs = __toESM(require("fs"));
var import_lodash = __toESM(require("lodash"));
var import_path = __toESM(require("path"));
var import_semver = __toESM(require("semver"));
var codegen = __toESM(require("../code-generation"));
var consts = __toESM(require("../consts"));
var errors = __toESM(require("../errors"));
var import_integration_ref = require("../integration-ref");
var import_validate_integration = require("../sdk/validate-integration");
var utils = __toESM(require("../utils"));
var import_global_command = require("./global-command");
class ProjectPaths extends utils.path.PathStore {
  constructor(argv) {
    const absWorkDir = utils.path.absoluteFrom(utils.path.cwd(), argv.workDir);
    const absEntrypoint = utils.path.absoluteFrom(absWorkDir, argv.entryPoint);
    const absOutDir = utils.path.absoluteFrom(absWorkDir, argv.outDir);
    super({
      workDir: absWorkDir,
      entryPoint: absEntrypoint,
      outDir: absOutDir,
      ...import_lodash.default.mapValues(consts.fromOutDir, (p) => utils.path.absoluteFrom(absOutDir, p)),
      ...import_lodash.default.mapValues(consts.fromWorkDir, (p) => utils.path.absoluteFrom(absWorkDir, p))
    });
  }
}
class ProjectCommand extends import_global_command.GlobalCommand {
  async bootstrap() {
    await super.bootstrap();
    await this._notifyUpdateSdk();
  }
  get projectPaths() {
    return new ProjectPaths(this.argv);
  }
  get projectCache() {
    return new utils.cache.FSKeyValueCache(this.projectPaths.abs.projectCacheFile);
  }
  async fetchBotIntegrationInstances(bot, api) {
    const integrationList = (0, import_lodash.default)(bot.props.integrations).values().filter(utils.guards.is.defined).value();
    const { remoteInstances, localInstances } = this._splitApiAndLocalIntegrationInstances(integrationList);
    const fetchedInstances = await import_bluebird.default.map(localInstances, async (instance) => {
      const ref = { type: "name", name: instance.name, version: instance.version };
      const integration = await api.findIntegration(ref);
      if (!integration) {
        const formattedRef = (0, import_integration_ref.formatIntegrationRef)(ref);
        throw new errors.BotpressCLIError(`Integration "${formattedRef}" not found`);
      }
      return { ...instance, id: integration.id };
    });
    return (0, import_lodash.default)([...fetchedInstances, ...remoteInstances]).keyBy((i) => i.id).mapValues(({ enabled, configuration }) => ({ enabled, configuration })).value();
  }
  _splitApiAndLocalIntegrationInstances(instances) {
    const remoteInstances = [];
    const localInstances = [];
    for (const { id, ...instance } of instances) {
      if (id) {
        remoteInstances.push({ ...instance, id });
      } else {
        localInstances.push({ ...instance, id: null });
      }
    }
    return { remoteInstances, localInstances };
  }
  async readIntegrationDefinitionFromFS(projectPaths = this.projectPaths) {
    const abs = projectPaths.abs;
    const rel = projectPaths.rel("workDir");
    if (!import_fs.default.existsSync(abs.definition)) {
      this.logger.debug(`Integration definition not found at ${rel.definition}`);
      return;
    }
    const { outputFiles } = await utils.esbuild.buildEntrypoint({
      cwd: abs.workDir,
      outfile: "",
      entrypoint: rel.definition,
      write: false
    });
    const artifact = outputFiles[0];
    if (!artifact) {
      throw new errors.BotpressCLIError("Could not read integration definition");
    }
    const { default: definition } = utils.require.requireJsCode(artifact.text);
    (0, import_validate_integration.validateIntegrationDefinition)(definition);
    return definition;
  }
  async writeGeneratedFilesToOutFolder(files) {
    for (const file of files) {
      const filePath = utils.path.absoluteFrom(this.projectPaths.abs.outDir, file.path);
      const dirPath = import_path.default.dirname(filePath);
      await import_fs.default.promises.mkdir(dirPath, { recursive: true });
      await import_fs.default.promises.writeFile(filePath, file.content);
    }
  }
  displayWebhookUrls(bot) {
    if (!import_lodash.default.keys(bot.integrations).length) {
      this.logger.debug("No integrations in bot");
      return;
    }
    this.logger.log("Integrations:");
    for (const integration of Object.values(bot.integrations).filter(utils.guards.is.defined)) {
      if (!integration.enabled) {
        this.logger.log(`${import_chalk.default.grey(integration.name)} ${import_chalk.default.italic("(disabled)")}: ${integration.webhookUrl}`, {
          prefix: { symbol: "\u25CB", indent: 2 }
        });
      } else {
        this.logger.log(`${import_chalk.default.bold(integration.name)} : ${integration.webhookUrl}`, {
          prefix: { symbol: "\u25CF", indent: 2 }
        });
      }
    }
  }
  async promptSecrets(integrationDef, argv, opts = {}) {
    const formatEnv = opts.formatEnv ?? false;
    const knownSecrets = opts.knownSecrets ?? [];
    const { secrets: secretDefinitions } = integrationDef;
    if (!secretDefinitions) {
      return {};
    }
    const secretArgv = this._parseArgvSecrets(argv.secrets);
    const invalidSecret = Object.keys(secretArgv).find((s) => !secretDefinitions[s]);
    if (invalidSecret) {
      throw new errors.BotpressCLIError(`Secret ${invalidSecret} is not defined in integration definition`);
    }
    const values = {};
    for (const [secretName, { optional }] of Object.entries(secretDefinitions)) {
      const argvSecret = secretArgv[secretName];
      if (argvSecret) {
        this.logger.debug(`Using secret "${secretName}" from argv`);
        values[secretName] = argvSecret;
        continue;
      }
      const alreadyKnown = knownSecrets.includes(secretName);
      let mode;
      if (alreadyKnown) {
        mode = "already set";
      } else if (optional) {
        mode = "optional";
      } else {
        mode = "required";
      }
      const prompted = await this.prompt.text(`Enter value for secret "${secretName}" (${mode})`);
      if (prompted) {
        values[secretName] = prompted;
        continue;
      }
      if (alreadyKnown) {
        this.logger.log(`Secret "${secretName}" is unchanged`);
      } else if (optional) {
        this.logger.warn(`Secret "${secretName}" is unassigned`);
      } else {
        throw new errors.BotpressCLIError(`Secret "${secretName}" is required`);
      }
    }
    for (const secretName of knownSecrets) {
      const isDefined = secretName in secretDefinitions;
      if (isDefined) {
        continue;
      }
      const prompted = await this.prompt.confirm(`Secret "${secretName}" was removed. Do you wish to delete it?`);
      if (prompted) {
        this.logger.log(`Deleting secret "${secretName}"`, { prefix: { symbol: "\xD7", fg: "red" } });
        values[secretName] = null;
      }
    }
    if (!formatEnv) {
      return values;
    }
    const envVariables = import_lodash.default.mapKeys(values, (_v, k) => codegen.secretEnvVariableName(k));
    return envVariables;
  }
  _parseArgvSecrets(argvSecrets) {
    const parsed = {};
    for (const secret of argvSecrets) {
      const [key, value] = utils.string.splitOnce(secret, "=");
      if (!value) {
        throw new errors.BotpressCLIError(
          `Secret "${key}" is missing a value. Expected format: "SECRET_NAME=secretValue"`
        );
      }
      parsed[key] = value;
    }
    return parsed;
  }
  _notifyUpdateSdk = async () => {
    try {
      this.logger.debug("Checking if sdk is up to date");
      const { workDir } = this.projectPaths.abs;
      const projectPkgJson = await utils.pkgJson.readPackageJson(workDir);
      if (!projectPkgJson) {
        this.logger.debug(`Could not find package.json at "${workDir}"`);
        return;
      }
      const sdkPackageName = "@botpress/sdk";
      const actualSdkVersion = utils.pkgJson.findDependency(projectPkgJson, sdkPackageName);
      if (!actualSdkVersion) {
        this.logger.debug(`Could not find dependency "${sdkPackageName}" in project package.json`);
        return;
      }
      if (actualSdkVersion.startsWith("workspace:")) {
        return;
      }
      const actualCleanedSdkVersion = import_semver.default.valid(import_semver.default.coerce(actualSdkVersion));
      if (!actualCleanedSdkVersion) {
        this.logger.debug(`Invalid sdk version "${actualSdkVersion}" in project package.json`);
        return;
      }
      const cliPkgJson = await this.readPkgJson();
      const expectedSdkVersion = utils.pkgJson.findDependency(cliPkgJson, sdkPackageName);
      if (!expectedSdkVersion) {
        this.logger.debug(`Could not find dependency "${sdkPackageName}" in cli package.json`);
        return;
      }
      const expectedCleanedSdkVersion = import_semver.default.valid(import_semver.default.coerce(expectedSdkVersion));
      if (!expectedCleanedSdkVersion) {
        this.logger.debug(`Invalid sdk version "${expectedSdkVersion}" in cli package.json`);
        return;
      }
      if (import_semver.default.eq(actualCleanedSdkVersion, expectedCleanedSdkVersion)) {
        return;
      }
      const diff = import_semver.default.diff(actualCleanedSdkVersion, expectedCleanedSdkVersion);
      if (!diff) {
        this.logger.debug(`Could not compare versions "${actualCleanedSdkVersion}" and "${expectedCleanedSdkVersion}"`);
        return;
      }
      const errorMsg = `Project SDK version is "${actualCleanedSdkVersion}", but expected "${expectedCleanedSdkVersion}"`;
      if (utils.semver.releases.lt(diff, "minor")) {
        this.logger.debug(`${errorMsg}. This may cause compatibility issues.`);
        return;
      }
      this.logger.warn(import_chalk.default.bold(`${errorMsg}. This will cause compatibility issues.`));
    } catch (thrown) {
      const err = errors.BotpressCLIError.map(thrown);
      this.logger.debug(`Failed to check if sdk is up to date: ${err.message}`);
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ProjectCommand
});
//# sourceMappingURL=project-command.js.map
