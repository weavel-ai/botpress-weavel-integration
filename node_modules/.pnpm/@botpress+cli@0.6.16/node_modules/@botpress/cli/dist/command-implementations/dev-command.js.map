{
  "version": 3,
  "sources": ["../../src/command-implementations/dev-command.ts"],
  "sourcesContent": ["import type * as client from '@botpress/client'\nimport type * as sdk from '@botpress/sdk'\nimport { TunnelRequest, TunnelResponse } from '@bpinternal/tunnel'\nimport axios, { AxiosRequestConfig, AxiosResponse } from 'axios'\nimport chalk from 'chalk'\nimport * as pathlib from 'path'\nimport * as uuid from 'uuid'\nimport { prepareCreateBotBody, prepareUpdateBotBody } from '../api/bot-body'\nimport type { ApiClient } from '../api/client'\nimport {\n  prepareUpdateIntegrationBody,\n  CreateIntegrationBody,\n  prepareCreateIntegrationBody,\n} from '../api/integration-body'\nimport type commandDefinitions from '../command-definitions'\nimport * as errors from '../errors'\nimport * as utils from '../utils'\nimport { Worker } from '../worker'\nimport { BuildCommand } from './build-command'\nimport { ProjectCommand } from './project-command'\n\nconst DEFAULT_BOT_PORT = 8075\nconst DEFAULT_INTEGRATION_PORT = 8076\nconst TUNNEL_HELLO_INTERVAL = 5000\n\nexport type DevCommandDefinition = typeof commandDefinitions.dev\nexport class DevCommand extends ProjectCommand<DevCommandDefinition> {\n  private _initialDef: sdk.IntegrationDefinition | undefined = undefined\n\n  public async run(): Promise<void> {\n    this.logger.warn('This command is experimental and subject to breaking changes without notice.')\n\n    const api = await this.ensureLoginAndCreateClient(this.argv)\n\n    this._initialDef = await this.readIntegrationDefinitionFromFS()\n\n    let env: Record<string, string> = {\n      ...process.env,\n      BP_API_URL: api.url,\n      BP_TOKEN: api.token,\n    }\n\n    let defaultPort = DEFAULT_BOT_PORT\n    if (this._initialDef) {\n      defaultPort = DEFAULT_INTEGRATION_PORT\n      // TODO: store secrets in local cache to avoid prompting every time\n      const secretEnvVariables = await this.promptSecrets(this._initialDef, this.argv, { formatEnv: true })\n      const nonNullSecretEnvVariables = utils.records.filterValues(secretEnvVariables, utils.guards.is.notNull)\n      env = { ...env, ...nonNullSecretEnvVariables }\n    }\n\n    const port = this.argv.port ?? defaultPort\n\n    const urlParseResult = utils.url.parse(this.argv.tunnelUrl)\n    if (urlParseResult.status === 'error') {\n      throw new errors.BotpressCLIError(`Invalid tunnel URL: ${urlParseResult.error}`)\n    }\n\n    const tunnelId = uuid.v4()\n\n    const { url: parsedTunnelUrl } = urlParseResult\n    const isSecured = parsedTunnelUrl.protocol === 'https' || parsedTunnelUrl.protocol === 'wss'\n\n    const wsTunnelUrl: string = utils.url.format({ ...parsedTunnelUrl, protocol: isSecured ? 'wss' : 'ws' })\n    const httpTunnelUrl: string = utils.url.format({\n      ...parsedTunnelUrl,\n      protocol: isSecured ? 'https' : 'http',\n      path: `/${tunnelId}`,\n    })\n\n    let worker: Worker | undefined = undefined\n\n    const supervisor = new utils.tunnel.TunnelSupervisor(wsTunnelUrl, tunnelId, this.logger)\n    supervisor.events.on('connected', ({ tunnel }) => {\n      // prevents the tunnel from closing due to inactivity\n      const timer = setInterval(() => {\n        if (tunnel.closed) {\n          return handleClose()\n        }\n        tunnel.hello()\n      }, TUNNEL_HELLO_INTERVAL)\n      const handleClose = (): void => clearInterval(timer)\n      tunnel.events.on('close', handleClose)\n\n      tunnel.events.on('request', (req) => {\n        if (!worker) {\n          this.logger.debug('Worker not ready yet, ignoring request')\n          tunnel.send({ requestId: req.id, status: 503, body: 'Worker not ready yet' })\n          return\n        }\n\n        void this._forwardTunnelRequest(`http://localhost:${port}`, req)\n          .then((res) => {\n            tunnel.send(res)\n          })\n          .catch((thrown) => {\n            const err = errors.BotpressCLIError.wrap(thrown, 'An error occurred while handling request')\n            this.logger.error(err.message)\n            tunnel.send({\n              requestId: req.id,\n              status: 500,\n              body: err.message,\n            })\n          })\n      })\n    })\n\n    supervisor.events.on('manuallyClosed', () => {\n      this.logger.debug('Tunnel manually closed')\n    })\n\n    await supervisor.start()\n\n    await this._runBuild()\n    await this._deploy(api, httpTunnelUrl)\n    worker = await this._spawnWorker(env, port)\n\n    try {\n      const watcher = await utils.filewatcher.FileWatcher.watch(\n        this.argv.workDir,\n        async (events) => {\n          if (!worker) {\n            this.logger.debug('Worker not ready yet, ignoring file change event')\n            return\n          }\n\n          const typescriptEvents = events.filter((e) => pathlib.extname(e.path) === '.ts')\n          if (typescriptEvents.length === 0) {\n            return\n          }\n\n          this.logger.log('Changes detected, rebuilding')\n          await this._restart(api, worker, httpTunnelUrl)\n        },\n        {\n          ignore: [this.projectPaths.abs.outDir],\n        }\n      )\n\n      await Promise.race([worker.wait(), watcher.wait(), supervisor.wait()])\n\n      if (worker.running) {\n        await worker.kill()\n      }\n      await watcher.close()\n      supervisor.close()\n    } catch (thrown) {\n      throw errors.BotpressCLIError.wrap(thrown, 'An error occurred while running the dev server')\n    } finally {\n      if (worker.running) {\n        await worker.kill()\n      }\n    }\n  }\n\n  private _restart = async (api: ApiClient, worker: Worker, tunnelUrl: string) => {\n    try {\n      await this._runBuild()\n    } catch (thrown) {\n      const error = errors.BotpressCLIError.wrap(thrown, 'Build failed')\n      this.logger.error(error.message)\n      return\n    }\n\n    await this._deploy(api, tunnelUrl)\n    await worker.reload()\n  }\n\n  private _deploy = async (api: ApiClient, tunnelUrl: string) => {\n    const integrationDef = await this.readIntegrationDefinitionFromFS()\n    if (integrationDef) {\n      this._checkSecrets(integrationDef)\n      await this._deployDevIntegration(api, tunnelUrl, integrationDef)\n    } else {\n      await this._deployDevBot(api, tunnelUrl)\n    }\n  }\n\n  private _checkSecrets(integrationDef: sdk.IntegrationDefinition) {\n    const initialSecrets = this._initialDef?.secrets ?? {}\n    const currentSecrets = integrationDef.secrets ?? {}\n    const newSecrets = Object.keys(currentSecrets).filter((s) => !initialSecrets[s])\n    if (newSecrets.length > 0) {\n      throw new errors.BotpressCLIError('Secrets were added while the server was running. A restart is required.')\n    }\n  }\n\n  private _spawnWorker = async (env: Record<string, string>, port: number) => {\n    const outfile = this.projectPaths.abs.outFile\n    const importPath = utils.path.toUnix(outfile)\n    const requireFrom = utils.path.rmExtension(importPath)\n    const code = `require('${requireFrom}').default.start(${port})`\n    const worker = await Worker.spawn(\n      {\n        type: 'code',\n        code,\n        env,\n      },\n      this.logger\n    ).catch((thrown) => {\n      throw errors.BotpressCLIError.wrap(thrown, 'Could not start dev worker')\n    })\n\n    return worker\n  }\n\n  private _runBuild() {\n    return new BuildCommand(this.api, this.prompt, this.logger, this.argv).run()\n  }\n\n  private async _deployDevIntegration(\n    api: ApiClient,\n    externalUrl: string,\n    integrationDef: sdk.IntegrationDefinition\n  ): Promise<void> {\n    const devId = await this.projectCache.get('devId')\n\n    let integration: client.Integration | undefined = undefined\n\n    if (devId) {\n      const resp = await api.client.getIntegration({ id: devId }).catch(async (thrown) => {\n        const err = errors.BotpressCLIError.wrap(thrown, `Could not find existing dev integration with id \"${devId}\"`)\n        this.logger.warn(err.message)\n        return { integration: undefined }\n      })\n\n      if (resp.integration?.dev) {\n        integration = resp.integration\n      } else {\n        await this.projectCache.rm('devId')\n      }\n    }\n\n    const line = this.logger.line()\n    line.started(`Deploying dev integration ${chalk.bold(integrationDef.name)}...`)\n\n    const createIntegrationBody: CreateIntegrationBody = {\n      ...prepareCreateIntegrationBody(integrationDef),\n      url: externalUrl,\n    }\n\n    if (integration) {\n      const updateIntegrationBody = prepareUpdateIntegrationBody(\n        { ...createIntegrationBody, id: integration.id },\n        integration\n      )\n\n      const resp = await api.client.updateIntegration(updateIntegrationBody).catch((thrown) => {\n        throw errors.BotpressCLIError.wrap(thrown, `Could not update dev integration \"${integrationDef.name}\"`)\n      })\n      integration = resp.integration\n    } else {\n      const resp = await api.client.createIntegration({ ...createIntegrationBody, dev: true }).catch((thrown) => {\n        throw errors.BotpressCLIError.wrap(thrown, `Could not deploy dev integration \"${integrationDef.name}\"`)\n      })\n      integration = resp.integration\n    }\n\n    line.success(`Dev Integration deployed with id \"${integration.id}\"`)\n    line.commit()\n\n    await this.projectCache.set('devId', integration.id)\n  }\n\n  private async _deployDevBot(api: ApiClient, externalUrl: string): Promise<void> {\n    const devId = await this.projectCache.get('devId')\n\n    let bot: client.Bot | undefined = undefined\n\n    if (devId) {\n      const resp = await api.client.getBot({ id: devId }).catch(async (thrown) => {\n        const err = errors.BotpressCLIError.wrap(thrown, `Could not find existing dev bot with id \"${devId}\"`)\n        this.logger.warn(err.message)\n        return { bot: undefined }\n      })\n\n      if (resp.bot?.dev) {\n        bot = resp.bot\n      } else {\n        await this.projectCache.rm('devId')\n      }\n    }\n\n    if (!bot) {\n      const createLine = this.logger.line()\n      createLine.started('Creating dev bot...')\n      const resp = await api.client\n        .createBot({\n          dev: true,\n          url: externalUrl,\n        })\n        .catch((thrown) => {\n          throw errors.BotpressCLIError.wrap(thrown, 'Could not deploy dev bot')\n        })\n\n      bot = resp.bot\n      createLine.success(`Dev Bot created with id \"${bot.id}\"`)\n      createLine.commit()\n      await this.projectCache.set('devId', bot.id)\n    }\n\n    const outfile = this.projectPaths.abs.outFile\n    const { default: botImpl } = utils.require.requireJsFile<{ default: sdk.Bot }>(outfile)\n\n    const updateLine = this.logger.line()\n    updateLine.started('Deploying dev bot...')\n\n    const integrationInstances = await this.fetchBotIntegrationInstances(botImpl, api)\n    const updateBotBody = prepareUpdateBotBody(\n      {\n        ...prepareCreateBotBody(botImpl),\n        id: bot.id,\n        url: externalUrl,\n        integrations: integrationInstances,\n      },\n      bot\n    )\n\n    const { bot: updatedBot } = await api.client.updateBot(updateBotBody).catch((thrown) => {\n      throw errors.BotpressCLIError.wrap(thrown, 'Could not deploy dev bot')\n    })\n    updateLine.success(`Dev Bot deployed with id \"${updatedBot.id}\"`)\n    updateLine.commit()\n\n    this.displayWebhookUrls(updatedBot)\n  }\n\n  private _forwardTunnelRequest = async (baseUrl: string, request: TunnelRequest): Promise<TunnelResponse> => {\n    const axiosConfig = {\n      method: request.method,\n      url: this._formatLocalUrl(baseUrl, request),\n      headers: request.headers,\n      data: request.body,\n      responseType: 'text',\n      validateStatus: () => true,\n    } satisfies AxiosRequestConfig\n\n    this.logger.debug(`Forwarding request to ${axiosConfig.url}`)\n    const response = await axios(axiosConfig)\n    this.logger.debug('Sending back response up the tunnel')\n\n    return {\n      requestId: request.id,\n      status: response.status,\n      headers: this._getHeaders(response.headers),\n      body: response.data,\n    }\n  }\n\n  private _formatLocalUrl = (baseUrl: string, req: TunnelRequest): string => {\n    if (req.query) {\n      return `${baseUrl}${req.path}?${req.query}`\n    }\n    return `${baseUrl}${req.path}`\n  }\n\n  private _getHeaders = (res: AxiosResponse['headers']): TunnelResponse['headers'] => {\n    const headers: TunnelResponse['headers'] = {}\n    for (const key in res) {\n      if (typeof res[key] === 'string' || typeof res[key] === 'number') {\n        headers[key] = res[key]\n      }\n    }\n    return headers\n  }\n}\n"],
  "mappings": "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",
  "names": ["chalk", "axios"]
}
