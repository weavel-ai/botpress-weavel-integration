{
  "version": 3,
  "sources": ["../../src/command-implementations/project-command.ts"],
  "sourcesContent": ["import type * as client from '@botpress/client'\nimport type * as sdk from '@botpress/sdk'\nimport type { YargsConfig } from '@bpinternal/yargs-extra'\nimport bluebird from 'bluebird'\nimport chalk from 'chalk'\nimport fs from 'fs'\nimport _ from 'lodash'\nimport pathlib from 'path'\nimport semver from 'semver'\nimport { ApiClient } from '../api/client'\nimport * as codegen from '../code-generation'\nimport type * as config from '../config'\nimport * as consts from '../consts'\nimport * as errors from '../errors'\nimport { formatIntegrationRef, IntegrationRef } from '../integration-ref'\nimport { validateIntegrationDefinition } from '../sdk/validate-integration'\nimport type { CommandArgv, CommandDefinition } from '../typings'\nimport * as utils from '../utils'\nimport { GlobalCommand } from './global-command'\n\nexport type ProjectCommandDefinition = CommandDefinition<typeof config.schemas.project>\nexport type ProjectCache = { botId: string; devId: string }\n\ntype ConfigurableProjectPaths = { entryPoint: string; outDir: string; workDir: string }\ntype ConstantProjectPaths = typeof consts.fromOutDir & typeof consts.fromWorkDir\ntype AllProjectPaths = ConfigurableProjectPaths & ConstantProjectPaths\n\ntype RemoteIntegrationInstance = utils.types.Merge<sdk.IntegrationInstance<string>, { id: string }>\ntype LocalIntegrationInstance = utils.types.Merge<sdk.IntegrationInstance<string>, { id: null }>\n\nclass ProjectPaths extends utils.path.PathStore<keyof AllProjectPaths> {\n  public constructor(argv: CommandArgv<ProjectCommandDefinition>) {\n    const absWorkDir = utils.path.absoluteFrom(utils.path.cwd(), argv.workDir)\n    const absEntrypoint = utils.path.absoluteFrom(absWorkDir, argv.entryPoint)\n    const absOutDir = utils.path.absoluteFrom(absWorkDir, argv.outDir)\n    super({\n      workDir: absWorkDir,\n      entryPoint: absEntrypoint,\n      outDir: absOutDir,\n      ..._.mapValues(consts.fromOutDir, (p) => utils.path.absoluteFrom(absOutDir, p)),\n      ..._.mapValues(consts.fromWorkDir, (p) => utils.path.absoluteFrom(absWorkDir, p)),\n    })\n  }\n}\n\nexport abstract class ProjectCommand<C extends ProjectCommandDefinition> extends GlobalCommand<C> {\n  protected override async bootstrap() {\n    await super.bootstrap()\n    await this._notifyUpdateSdk()\n  }\n\n  protected get projectPaths() {\n    return new ProjectPaths(this.argv)\n  }\n\n  protected get projectCache() {\n    return new utils.cache.FSKeyValueCache<ProjectCache>(this.projectPaths.abs.projectCacheFile)\n  }\n\n  protected async fetchBotIntegrationInstances(bot: sdk.Bot, api: ApiClient) {\n    const integrationList = _(bot.props.integrations).values().filter(utils.guards.is.defined).value()\n\n    const { remoteInstances, localInstances } = this._splitApiAndLocalIntegrationInstances(integrationList)\n\n    const fetchedInstances: RemoteIntegrationInstance[] = await bluebird.map(localInstances, async (instance) => {\n      const ref: IntegrationRef = { type: 'name', name: instance.name, version: instance.version }\n      const integration = await api.findIntegration(ref)\n      if (!integration) {\n        const formattedRef = formatIntegrationRef(ref)\n        throw new errors.BotpressCLIError(`Integration \"${formattedRef}\" not found`)\n      }\n      return { ...instance, id: integration.id }\n    })\n\n    return _([...fetchedInstances, ...remoteInstances])\n      .keyBy((i) => i.id)\n      .mapValues(({ enabled, configuration }) => ({ enabled, configuration }))\n      .value()\n  }\n\n  private _splitApiAndLocalIntegrationInstances(instances: sdk.IntegrationInstance<string>[]): {\n    remoteInstances: RemoteIntegrationInstance[]\n    localInstances: LocalIntegrationInstance[]\n  } {\n    const remoteInstances: RemoteIntegrationInstance[] = []\n    const localInstances: LocalIntegrationInstance[] = []\n    for (const { id, ...instance } of instances) {\n      if (id) {\n        remoteInstances.push({ ...instance, id })\n      } else {\n        localInstances.push({ ...instance, id: null })\n      }\n    }\n\n    return { remoteInstances, localInstances }\n  }\n\n  protected async readIntegrationDefinitionFromFS(\n    projectPaths: utils.path.PathStore<'workDir' | 'definition'> = this.projectPaths\n  ): Promise<sdk.IntegrationDefinition | undefined> {\n    const abs = projectPaths.abs\n    const rel = projectPaths.rel('workDir')\n\n    if (!fs.existsSync(abs.definition)) {\n      this.logger.debug(`Integration definition not found at ${rel.definition}`)\n      return\n    }\n\n    const { outputFiles } = await utils.esbuild.buildEntrypoint({\n      cwd: abs.workDir,\n      outfile: '',\n      entrypoint: rel.definition,\n      write: false,\n    })\n\n    const artifact = outputFiles[0]\n    if (!artifact) {\n      throw new errors.BotpressCLIError('Could not read integration definition')\n    }\n\n    const { default: definition } = utils.require.requireJsCode<{ default: sdk.IntegrationDefinition }>(artifact.text)\n\n    validateIntegrationDefinition(definition)\n\n    return definition\n  }\n\n  protected async writeGeneratedFilesToOutFolder(files: codegen.File[]) {\n    for (const file of files) {\n      const filePath = utils.path.absoluteFrom(this.projectPaths.abs.outDir, file.path)\n      const dirPath = pathlib.dirname(filePath)\n      await fs.promises.mkdir(dirPath, { recursive: true })\n      await fs.promises.writeFile(filePath, file.content)\n    }\n  }\n\n  protected displayWebhookUrls(bot: client.Bot) {\n    if (!_.keys(bot.integrations).length) {\n      this.logger.debug('No integrations in bot')\n      return\n    }\n\n    this.logger.log('Integrations:')\n    for (const integration of Object.values(bot.integrations).filter(utils.guards.is.defined)) {\n      if (!integration.enabled) {\n        this.logger.log(`${chalk.grey(integration.name)} ${chalk.italic('(disabled)')}: ${integration.webhookUrl}`, {\n          prefix: { symbol: '\u25CB', indent: 2 },\n        })\n      } else {\n        this.logger.log(`${chalk.bold(integration.name)} : ${integration.webhookUrl}`, {\n          prefix: { symbol: '\u25CF', indent: 2 },\n        })\n      }\n    }\n  }\n\n  protected async promptSecrets(\n    integrationDef: sdk.IntegrationDefinition,\n    argv: YargsConfig<typeof config.schemas.secrets>,\n    opts: { formatEnv?: boolean; knownSecrets?: string[] } = {}\n  ): Promise<Record<string, string | null>> {\n    const formatEnv = opts.formatEnv ?? false\n    const knownSecrets = opts.knownSecrets ?? []\n\n    const { secrets: secretDefinitions } = integrationDef\n    if (!secretDefinitions) {\n      return {}\n    }\n\n    const secretArgv = this._parseArgvSecrets(argv.secrets)\n    const invalidSecret = Object.keys(secretArgv).find((s) => !secretDefinitions[s])\n    if (invalidSecret) {\n      throw new errors.BotpressCLIError(`Secret ${invalidSecret} is not defined in integration definition`)\n    }\n\n    const values: Record<string, string | null> = {}\n    for (const [secretName, { optional }] of Object.entries(secretDefinitions)) {\n      const argvSecret = secretArgv[secretName]\n      if (argvSecret) {\n        this.logger.debug(`Using secret \"${secretName}\" from argv`)\n        values[secretName] = argvSecret\n        continue\n      }\n\n      const alreadyKnown = knownSecrets.includes(secretName)\n      let mode: string\n      if (alreadyKnown) {\n        mode = 'already set'\n      } else if (optional) {\n        mode = 'optional'\n      } else {\n        mode = 'required'\n      }\n\n      const prompted = await this.prompt.text(`Enter value for secret \"${secretName}\" (${mode})`)\n      if (prompted) {\n        values[secretName] = prompted\n        continue\n      }\n\n      if (alreadyKnown) {\n        this.logger.log(`Secret \"${secretName}\" is unchanged`)\n      } else if (optional) {\n        this.logger.warn(`Secret \"${secretName}\" is unassigned`)\n      } else {\n        throw new errors.BotpressCLIError(`Secret \"${secretName}\" is required`)\n      }\n    }\n\n    for (const secretName of knownSecrets) {\n      const isDefined = secretName in secretDefinitions\n      if (isDefined) {\n        continue\n      }\n      const prompted = await this.prompt.confirm(`Secret \"${secretName}\" was removed. Do you wish to delete it?`)\n      if (prompted) {\n        this.logger.log(`Deleting secret \"${secretName}\"`, { prefix: { symbol: '\u00D7', fg: 'red' } })\n        values[secretName] = null\n      }\n    }\n\n    if (!formatEnv) {\n      return values\n    }\n\n    const envVariables = _.mapKeys(values, (_v, k) => codegen.secretEnvVariableName(k))\n    return envVariables\n  }\n\n  private _parseArgvSecrets(argvSecrets: string[]): Record<string, string> {\n    const parsed: Record<string, string> = {}\n    for (const secret of argvSecrets) {\n      const [key, value] = utils.string.splitOnce(secret, '=')\n      if (!value) {\n        throw new errors.BotpressCLIError(\n          `Secret \"${key}\" is missing a value. Expected format: \"SECRET_NAME=secretValue\"`\n        )\n      }\n      parsed[key!] = value\n    }\n\n    return parsed\n  }\n\n  private _notifyUpdateSdk = async (): Promise<void> => {\n    try {\n      this.logger.debug('Checking if sdk is up to date')\n\n      const { workDir } = this.projectPaths.abs\n      const projectPkgJson = await utils.pkgJson.readPackageJson(workDir)\n      if (!projectPkgJson) {\n        this.logger.debug(`Could not find package.json at \"${workDir}\"`)\n        return\n      }\n\n      const sdkPackageName = '@botpress/sdk'\n      const actualSdkVersion = utils.pkgJson.findDependency(projectPkgJson, sdkPackageName)\n      if (!actualSdkVersion) {\n        this.logger.debug(`Could not find dependency \"${sdkPackageName}\" in project package.json`)\n        return\n      }\n\n      if (actualSdkVersion.startsWith('workspace:')) {\n        return\n      }\n\n      const actualCleanedSdkVersion = semver.valid(semver.coerce(actualSdkVersion))\n      if (!actualCleanedSdkVersion) {\n        this.logger.debug(`Invalid sdk version \"${actualSdkVersion}\" in project package.json`)\n        return\n      }\n\n      const cliPkgJson = await this.readPkgJson()\n      const expectedSdkVersion = utils.pkgJson.findDependency(cliPkgJson, sdkPackageName)\n      if (!expectedSdkVersion) {\n        this.logger.debug(`Could not find dependency \"${sdkPackageName}\" in cli package.json`)\n        return\n      }\n\n      const expectedCleanedSdkVersion = semver.valid(semver.coerce(expectedSdkVersion))\n      if (!expectedCleanedSdkVersion) {\n        this.logger.debug(`Invalid sdk version \"${expectedSdkVersion}\" in cli package.json`)\n        return\n      }\n\n      if (semver.eq(actualCleanedSdkVersion, expectedCleanedSdkVersion)) {\n        return\n      }\n\n      const diff = semver.diff(actualCleanedSdkVersion, expectedCleanedSdkVersion)\n      if (!diff) {\n        this.logger.debug(`Could not compare versions \"${actualCleanedSdkVersion}\" and \"${expectedCleanedSdkVersion}\"`)\n        return\n      }\n\n      const errorMsg = `Project SDK version is \"${actualCleanedSdkVersion}\", but expected \"${expectedCleanedSdkVersion}\"`\n      if (utils.semver.releases.lt(diff, 'minor')) {\n        this.logger.debug(`${errorMsg}. This may cause compatibility issues.`)\n        return\n      }\n\n      this.logger.warn(chalk.bold(`${errorMsg}. This will cause compatibility issues.`))\n    } catch (thrown) {\n      const err = errors.BotpressCLIError.map(thrown)\n      this.logger.debug(`Failed to check if sdk is up to date: ${err.message}`)\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["_", "bluebird", "fs", "pathlib", "chalk", "semver"]
}
