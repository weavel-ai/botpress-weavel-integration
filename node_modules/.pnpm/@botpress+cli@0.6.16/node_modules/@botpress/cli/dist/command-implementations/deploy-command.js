"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var deploy_command_exports = {};
__export(deploy_command_exports, {
  DeployCommand: () => DeployCommand
});
module.exports = __toCommonJS(deploy_command_exports);
var import_chalk = __toESM(require("chalk"));
var fs = __toESM(require("fs"));
var import_bot_body = require("../api/bot-body");
var import_integration_body = require("../api/integration-body");
var errors = __toESM(require("../errors"));
var utils = __toESM(require("../utils"));
var import_build_command = require("./build-command");
var import_project_command = require("./project-command");
class DeployCommand extends import_project_command.ProjectCommand {
  async run() {
    const api = await this.ensureLoginAndCreateClient(this.argv);
    if (!this.argv.noBuild) {
      await this._runBuild();
    }
    const integrationDef = await this.readIntegrationDefinitionFromFS();
    if (integrationDef) {
      return this._deployIntegration(api, integrationDef);
    }
    return this._deployBot(api, this.argv.botId, this.argv.createNewBot);
  }
  async _runBuild() {
    return new import_build_command.BuildCommand(this.api, this.prompt, this.logger, this.argv).run();
  }
  async _deployIntegration(api, integrationDef) {
    const outfile = this.projectPaths.abs.outFile;
    const code = await fs.promises.readFile(outfile, "utf-8");
    const {
      name,
      version,
      icon: iconRelativeFilePath,
      readme: readmeRelativeFilePath,
      identifier,
      configuration
    } = integrationDef;
    if (iconRelativeFilePath && !iconRelativeFilePath.toLowerCase().endsWith(".svg")) {
      throw new errors.BotpressCLIError("Icon must be an SVG file");
    }
    const iconFileContent = await this._readMediaFile("icon", iconRelativeFilePath);
    const readmeFileContent = await this._readMediaFile("readme", readmeRelativeFilePath);
    const identifierExtractScriptFileContent = await this._readFile(identifier?.extractScript);
    const fallbackHandlerScriptFileContent = await this._readFile(identifier?.fallbackHandlerScript);
    const identifierLinkTemplateFileContent = await this._readFile(configuration?.identifier?.linkTemplateScript);
    const integration = await api.findIntegration({ type: "name", name, version });
    if (integration && !integration.workspaceId) {
      throw new errors.BotpressCLIError(
        `Public integration ${integrationDef.name} v${integrationDef.version} is already deployed in another workspace.`
      );
    }
    let message;
    if (integration) {
      this.logger.warn("Integration already exists. If you decide to deploy, it will overwrite the existing one.");
      message = `Are you sure you want to override integration ${integrationDef.name} v${integrationDef.version}?`;
    } else {
      message = `Are you sure you want to deploy integration ${integrationDef.name} v${integrationDef.version}?`;
    }
    const confirm = await this.prompt.confirm(message);
    if (!confirm) {
      this.logger.log("Aborted");
      return;
    }
    let createBody = (0, import_integration_body.prepareCreateIntegrationBody)(integrationDef);
    createBody = {
      ...createBody,
      code,
      icon: iconFileContent,
      readme: readmeFileContent,
      configuration: {
        ...createBody.configuration,
        identifier: {
          ...createBody.configuration?.identifier ?? {},
          linkTemplateScript: identifierLinkTemplateFileContent
        }
      },
      identifier: {
        extractScript: identifierExtractScriptFileContent,
        fallbackHandlerScript: fallbackHandlerScriptFileContent
      },
      public: this.argv.public
    };
    const startedMessage = `Deploying integration ${import_chalk.default.bold(integrationDef.name)} v${integrationDef.version}...`;
    const successMessage = "Integration deployed";
    if (integration) {
      const updateBody = (0, import_integration_body.prepareUpdateIntegrationBody)(
        {
          id: integration.id,
          ...createBody,
          public: this.argv.public
        },
        integration
      );
      const { secrets: knownSecrets } = integration;
      updateBody.secrets = await this.promptSecrets(integrationDef, this.argv, { knownSecrets });
      this._detectDeprecatedFeatures(integrationDef, { allowDeprecated: true });
      const line = this.logger.line();
      line.started(startedMessage);
      await api.client.updateIntegration(updateBody).catch((thrown) => {
        throw errors.BotpressCLIError.wrap(thrown, `Could not update integration "${integrationDef.name}"`);
      });
      line.success(successMessage);
    } else {
      const createSecrets = await this.promptSecrets(integrationDef, this.argv);
      createBody.secrets = utils.records.filterValues(createSecrets, utils.guards.is.notNull);
      this._detectDeprecatedFeatures(integrationDef, this.argv);
      const line = this.logger.line();
      line.started(startedMessage);
      await api.client.createIntegration(createBody).catch((thrown) => {
        throw errors.BotpressCLIError.wrap(thrown, `Could not create integration "${integrationDef.name}"`);
      });
      line.success(successMessage);
    }
  }
  _detectDeprecatedFeatures(integrationDef, opts = {}) {
    const deprecatedFields = [];
    const { user, channels } = integrationDef;
    if (user?.creation?.enabled) {
      deprecatedFields.push("user.creation");
    }
    for (const [channelName, channel] of Object.entries(channels ?? {})) {
      if (channel?.conversation?.creation?.enabled) {
        deprecatedFields.push(`channels.${channelName}.creation`);
      }
    }
    if (!deprecatedFields.length) {
      return;
    }
    const errorMessage = `The following fields of the integration's definition are deprecated: ${deprecatedFields.join(
      ", "
    )}`;
    if (opts.allowDeprecated) {
      this.logger.warn(errorMessage);
    } else {
      throw new errors.BotpressCLIError(errorMessage);
    }
  }
  _readFile = async (filePath) => {
    if (!filePath) {
      return void 0;
    }
    const absoluteFilePath = utils.path.absoluteFrom(this.projectPaths.abs.workDir, filePath);
    return fs.promises.readFile(absoluteFilePath, "utf-8").catch((thrown) => {
      throw errors.BotpressCLIError.wrap(thrown, `Could not read file "${absoluteFilePath}"`);
    });
  };
  _readMediaFile = async (filePurpose, filePath) => {
    if (!filePath) {
      return void 0;
    }
    const absoluteFilePath = utils.path.absoluteFrom(this.projectPaths.abs.workDir, filePath);
    return fs.promises.readFile(absoluteFilePath, "base64").catch((thrown) => {
      throw errors.BotpressCLIError.wrap(thrown, `Could not read ${filePurpose} file "${absoluteFilePath}"`);
    });
  };
  async _deployBot(api, argvBotId, argvCreateNew) {
    const outfile = this.projectPaths.abs.outFile;
    const code = await fs.promises.readFile(outfile, "utf-8");
    const { default: botImpl } = utils.require.requireJsFile(outfile);
    let bot;
    if (argvBotId && argvCreateNew) {
      throw new errors.BotpressCLIError("Cannot specify both --botId and --createNew");
    } else if (argvCreateNew) {
      const confirm = await this.prompt.confirm("Are you sure you want to create a new bot ?");
      if (!confirm) {
        this.logger.log("Aborted");
        return;
      }
      bot = await this._createNewBot(api);
    } else {
      bot = await this._getExistingBot(api, argvBotId);
      const confirm = await this.prompt.confirm(`Are you sure you want to deploy the bot "${bot.name}"?`);
      if (!confirm) {
        this.logger.log("Aborted");
        return;
      }
    }
    const line = this.logger.line();
    line.started(`Deploying bot ${import_chalk.default.bold(bot.name)}...`);
    const integrationInstances = await this.fetchBotIntegrationInstances(botImpl, api);
    const updateBotBody = (0, import_bot_body.prepareUpdateBotBody)(
      {
        ...(0, import_bot_body.prepareCreateBotBody)(botImpl),
        id: bot.id,
        code,
        integrations: integrationInstances
      },
      bot
    );
    const { bot: updatedBot } = await api.client.updateBot(updateBotBody).catch((thrown) => {
      throw errors.BotpressCLIError.wrap(thrown, `Could not update bot "${bot.name}"`);
    });
    line.success("Bot deployed");
    this.displayWebhookUrls(updatedBot);
  }
  async _createNewBot(api) {
    const line = this.logger.line();
    const { bot: createdBot } = await api.client.createBot({}).catch((thrown) => {
      throw errors.BotpressCLIError.wrap(thrown, "Could not create bot");
    });
    line.success(`Bot created with ID "${createdBot.id}" and name "${createdBot.name}"`);
    await this.projectCache.set("botId", createdBot.id);
    return createdBot;
  }
  async _getExistingBot(api, botId) {
    const promptedBotId = await this.projectCache.sync("botId", botId, async (defaultId) => {
      const userBots = await api.listAllPages(api.client.listBots, (r) => r.bots).catch((thrown) => {
        throw errors.BotpressCLIError.wrap(thrown, "Could not fetch existing bots");
      });
      if (!userBots.length) {
        throw new errors.NoBotsFoundError();
      }
      const initial = userBots.find((bot) => bot.id === defaultId);
      const prompted = await this.prompt.select("Which bot do you want to deploy?", {
        initial: initial && { title: initial.name, value: initial.id },
        choices: userBots.map((bot) => ({ title: bot.name, value: bot.id }))
      });
      if (!prompted) {
        throw new errors.ParamRequiredError("Bot Id");
      }
      return prompted;
    });
    const { bot: fetchedBot } = await api.client.getBot({ id: promptedBotId }).catch((thrown) => {
      throw errors.BotpressCLIError.wrap(thrown, "Could not get bot info");
    });
    return fetchedBot;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DeployCommand
});
//# sourceMappingURL=deploy-command.js.map
