{
  "version": 3,
  "sources": ["../../src/command-implementations/init-command.ts"],
  "sourcesContent": ["import chalk from 'chalk'\nimport * as fs from 'fs'\nimport * as pathlib from 'path'\nimport type commandDefinitions from '../command-definitions'\nimport * as consts from '../consts'\nimport * as errors from '../errors'\nimport * as utils from '../utils'\nimport { GlobalCommand } from './global-command'\n\nexport type InitCommandDefinition = typeof commandDefinitions.init\nexport class InitCommand extends GlobalCommand<InitCommandDefinition> {\n  public async run(): Promise<void> {\n    let { type: projectType } = this.argv\n\n    if (!projectType) {\n      const promptedType = await this.prompt.select('What type of project do you wish to initialize?', {\n        choices: (['bot', 'integration'] as const).map((t) => ({ title: t, value: t })),\n      })\n\n      if (!promptedType) {\n        throw new errors.ParamRequiredError('Project Type')\n      }\n\n      projectType = promptedType\n    }\n\n    let name = this.argv.name\n    if (!name) {\n      const defaultName = projectType === 'bot' ? consts.echoBotDirName : consts.emptyIntegrationDirName\n      const promptMessage = `What is the name of your ${projectType}?`\n      const promptedName = await this.prompt.text(promptMessage, { initial: defaultName })\n      if (!promptedName) {\n        throw new errors.ParamRequiredError('Project Name')\n      }\n      name = promptedName\n    }\n\n    const workDir = utils.path.absoluteFrom(utils.path.cwd(), this.argv.workDir)\n\n    if (projectType === 'bot') {\n      await this._copy({ srcDir: this.globalPaths.abs.echoBotTemplate, destDir: workDir, name })\n      this.logger.success(`Bot project initialized in ${chalk.bold(workDir)}`)\n      return\n    }\n\n    await this._copy({ srcDir: this.globalPaths.abs.emptyIntegrationTemplate, destDir: workDir, name })\n    this.logger.success(`Integration project initialized in ${chalk.bold(this.argv.workDir)}`)\n    return\n  }\n\n  private _copy = async (props: { srcDir: string; destDir: string; name: string }) => {\n    const { srcDir, destDir, name } = props\n\n    const dirName = utils.casing.to.kebabCase(name)\n    const destination = pathlib.join(destDir, dirName)\n\n    const exist = await this._checkIfDestinationExists(destination)\n    if (exist) {\n      return\n    }\n\n    await fs.promises.cp(srcDir, destination, { recursive: true })\n\n    const pkgJsonPath = pathlib.join(destination, 'package.json')\n    const strContent = await fs.promises.readFile(pkgJsonPath, 'utf-8')\n    const { name: _, integrationName: __, ...json } = JSON.parse(strContent)\n\n    const pkgJsonName = utils.casing.to.snakeCase(name)\n    const updatedJson = { name: pkgJsonName, integrationName: name, ...json }\n    await fs.promises.writeFile(pkgJsonPath, JSON.stringify(updatedJson, null, 2))\n  }\n\n  private _checkIfDestinationExists = async (destination: string) => {\n    if (fs.existsSync(destination)) {\n      const override = await this.prompt.confirm(\n        `Directory ${chalk.bold(destination)} already exists. Do you want to overwrite it?`\n      )\n      if (!override) {\n        this.logger.log('Aborting')\n        return true\n      }\n    }\n    return false\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAClB,SAAoB;AACpB,cAAyB;AAEzB,aAAwB;AACxB,aAAwB;AACxB,YAAuB;AACvB,4BAA8B;AAGvB,MAAM,oBAAoB,oCAAqC;AAAA,EACpE,MAAa,MAAqB;AAChC,QAAI,EAAE,MAAM,YAAY,IAAI,KAAK;AAEjC,QAAI,CAAC,aAAa;AAChB,YAAM,eAAe,MAAM,KAAK,OAAO,OAAO,mDAAmD;AAAA,QAC/F,SAAU,CAAC,OAAO,aAAa,EAAY,IAAI,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,EAAE,EAAE;AAAA,MAChF,CAAC;AAED,UAAI,CAAC,cAAc;AACjB,cAAM,IAAI,OAAO,mBAAmB,cAAc;AAAA,MACpD;AAEA,oBAAc;AAAA,IAChB;AAEA,QAAI,OAAO,KAAK,KAAK;AACrB,QAAI,CAAC,MAAM;AACT,YAAM,cAAc,gBAAgB,QAAQ,OAAO,iBAAiB,OAAO;AAC3E,YAAM,gBAAgB,4BAA4B;AAClD,YAAM,eAAe,MAAM,KAAK,OAAO,KAAK,eAAe,EAAE,SAAS,YAAY,CAAC;AACnF,UAAI,CAAC,cAAc;AACjB,cAAM,IAAI,OAAO,mBAAmB,cAAc;AAAA,MACpD;AACA,aAAO;AAAA,IACT;AAEA,UAAM,UAAU,MAAM,KAAK,aAAa,MAAM,KAAK,IAAI,GAAG,KAAK,KAAK,OAAO;AAE3E,QAAI,gBAAgB,OAAO;AACzB,YAAM,KAAK,MAAM,EAAE,QAAQ,KAAK,YAAY,IAAI,iBAAiB,SAAS,SAAS,KAAK,CAAC;AACzF,WAAK,OAAO,QAAQ,8BAA8B,aAAAA,QAAM,KAAK,OAAO,GAAG;AACvE;AAAA,IACF;AAEA,UAAM,KAAK,MAAM,EAAE,QAAQ,KAAK,YAAY,IAAI,0BAA0B,SAAS,SAAS,KAAK,CAAC;AAClG,SAAK,OAAO,QAAQ,sCAAsC,aAAAA,QAAM,KAAK,KAAK,KAAK,OAAO,GAAG;AACzF;AAAA,EACF;AAAA,EAEQ,QAAQ,OAAO,UAA6D;AAClF,UAAM,EAAE,QAAQ,SAAS,KAAK,IAAI;AAElC,UAAM,UAAU,MAAM,OAAO,GAAG,UAAU,IAAI;AAC9C,UAAM,cAAc,QAAQ,KAAK,SAAS,OAAO;AAEjD,UAAM,QAAQ,MAAM,KAAK,0BAA0B,WAAW;AAC9D,QAAI,OAAO;AACT;AAAA,IACF;AAEA,UAAM,GAAG,SAAS,GAAG,QAAQ,aAAa,EAAE,WAAW,KAAK,CAAC;AAE7D,UAAM,cAAc,QAAQ,KAAK,aAAa,cAAc;AAC5D,UAAM,aAAa,MAAM,GAAG,SAAS,SAAS,aAAa,OAAO;AAClE,UAAM,EAAE,MAAM,GAAG,iBAAiB,OAAO,KAAK,IAAI,KAAK,MAAM,UAAU;AAEvE,UAAM,cAAc,MAAM,OAAO,GAAG,UAAU,IAAI;AAClD,UAAM,cAAc,EAAE,MAAM,aAAa,iBAAiB,MAAM,GAAG,KAAK;AACxE,UAAM,GAAG,SAAS,UAAU,aAAa,KAAK,UAAU,aAAa,MAAM,CAAC,CAAC;AAAA,EAC/E;AAAA,EAEQ,4BAA4B,OAAO,gBAAwB;AACjE,QAAI,GAAG,WAAW,WAAW,GAAG;AAC9B,YAAM,WAAW,MAAM,KAAK,OAAO;AAAA,QACjC,aAAa,aAAAA,QAAM,KAAK,WAAW;AAAA,MACrC;AACA,UAAI,CAAC,UAAU;AACb,aAAK,OAAO,IAAI,UAAU;AAC1B,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACF;",
  "names": ["chalk"]
}
