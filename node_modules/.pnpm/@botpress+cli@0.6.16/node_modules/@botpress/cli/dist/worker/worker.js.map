{
  "version": 3,
  "sources": ["../../src/worker/worker.ts"],
  "sourcesContent": ["import type { Logger } from '../logger'\nimport { ChildProcessWrapper } from './child-wrapper'\nimport type { Config } from './config'\nimport { WorkerStateObserver } from './worker-state'\n\nexport type WorkerProps = {\n  hangOnExit?: boolean\n}\n\nexport class Worker {\n  public static async spawn(config: Config, logger: Logger, props?: Partial<WorkerProps>): Promise<Worker> {\n    const instance = new Worker(config, logger, props)\n    await instance.reload()\n    return instance\n  }\n\n  private _state = new WorkerStateObserver({ status: 'dead', murdered: false })\n\n  private constructor(private _config: Config, private _logger: Logger, private _props: Partial<WorkerProps> = {}) {}\n\n  /**\n   * Used to determine if the worker can be killed\n   */\n  public get running() {\n    return this._state.get().status === 'live'\n  }\n\n  public kill = () => {\n    const state = this._state.get()\n    if (state.status !== 'live') {\n      throw new Error('Cannot kill a child process that is not alive')\n    }\n\n    this._state.set({ status: 'killing' })\n    return state.child.kill()\n  }\n\n  public reload = async () => {\n    if (this._state.get().status === 'reloading') {\n      this._logger.debug('Already reloading')\n      return\n    }\n\n    const previousState = this._state.get()\n    this._state.set({ status: 'reloading' })\n\n    if (previousState.status === 'live') {\n      await previousState.child.kill()\n    }\n\n    const child = await ChildProcessWrapper.spawn(this._config, this._logger)\n    this._state.set({ status: 'live', child })\n\n    void child\n      .listen()\n      .catch((thrown) => {\n        this._state.set({ status: 'errored', thrown })\n      })\n      .then(() => {\n        const { status } = this._state.get()\n        if (status === 'reloading') {\n          return\n        }\n        this._state.set({ status: 'dead', murdered: status === 'killing' })\n      })\n  }\n\n  public wait = () =>\n    new Promise<void>((resolve, reject) => {\n      this._state.on('dead', (state) => {\n        if (state.murdered || !this._props.hangOnExit) {\n          resolve()\n          return\n        }\n\n        this._logger.debug('Child process died of natural causes...')\n      })\n\n      this._state.on('errored', (state) => {\n        reject(state.thrown)\n      })\n    })\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,2BAAoC;AAEpC,0BAAoC;AAM7B,MAAM,OAAO;AAAA,EASV,YAAoB,SAAyB,SAAyB,SAA+B,CAAC,GAAG;AAArF;AAAyB;AAAyB;AAAA,EAAoC;AAAA,EARlH,aAAoB,MAAM,QAAgB,QAAgB,OAA+C;AACvG,UAAM,WAAW,IAAI,OAAO,QAAQ,QAAQ,KAAK;AACjD,UAAM,SAAS,OAAO;AACtB,WAAO;AAAA,EACT;AAAA,EAEQ,SAAS,IAAI,wCAAoB,EAAE,QAAQ,QAAQ,UAAU,MAAM,CAAC;AAAA,EAO5E,IAAW,UAAU;AACnB,WAAO,KAAK,OAAO,IAAI,EAAE,WAAW;AAAA,EACtC;AAAA,EAEO,OAAO,MAAM;AAClB,UAAM,QAAQ,KAAK,OAAO,IAAI;AAC9B,QAAI,MAAM,WAAW,QAAQ;AAC3B,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,SAAK,OAAO,IAAI,EAAE,QAAQ,UAAU,CAAC;AACrC,WAAO,MAAM,MAAM,KAAK;AAAA,EAC1B;AAAA,EAEO,SAAS,YAAY;AAC1B,QAAI,KAAK,OAAO,IAAI,EAAE,WAAW,aAAa;AAC5C,WAAK,QAAQ,MAAM,mBAAmB;AACtC;AAAA,IACF;AAEA,UAAM,gBAAgB,KAAK,OAAO,IAAI;AACtC,SAAK,OAAO,IAAI,EAAE,QAAQ,YAAY,CAAC;AAEvC,QAAI,cAAc,WAAW,QAAQ;AACnC,YAAM,cAAc,MAAM,KAAK;AAAA,IACjC;AAEA,UAAM,QAAQ,MAAM,yCAAoB,MAAM,KAAK,SAAS,KAAK,OAAO;AACxE,SAAK,OAAO,IAAI,EAAE,QAAQ,QAAQ,MAAM,CAAC;AAEzC,SAAK,MACF,OAAO,EACP,MAAM,CAAC,WAAW;AACjB,WAAK,OAAO,IAAI,EAAE,QAAQ,WAAW,OAAO,CAAC;AAAA,IAC/C,CAAC,EACA,KAAK,MAAM;AACV,YAAM,EAAE,OAAO,IAAI,KAAK,OAAO,IAAI;AACnC,UAAI,WAAW,aAAa;AAC1B;AAAA,MACF;AACA,WAAK,OAAO,IAAI,EAAE,QAAQ,QAAQ,UAAU,WAAW,UAAU,CAAC;AAAA,IACpE,CAAC;AAAA,EACL;AAAA,EAEO,OAAO,MACZ,IAAI,QAAc,CAAC,SAAS,WAAW;AACrC,SAAK,OAAO,GAAG,QAAQ,CAAC,UAAU;AAChC,UAAI,MAAM,YAAY,CAAC,KAAK,OAAO,YAAY;AAC7C,gBAAQ;AACR;AAAA,MACF;AAEA,WAAK,QAAQ,MAAM,yCAAyC;AAAA,IAC9D,CAAC;AAED,SAAK,OAAO,GAAG,WAAW,CAAC,UAAU;AACnC,aAAO,MAAM,MAAM;AAAA,IACrB,CAAC;AAAA,EACH,CAAC;AACL;",
  "names": []
}
