{
  "version": 3,
  "sources": ["../../src/worker/child-wrapper.ts"],
  "sourcesContent": ["import * as childProcess from 'child_process'\nimport type { Logger } from '../logger'\nimport { ENTRY_POINT } from './child-entrypoint'\nimport { CONFIG_ENV_KEY, Config } from './config'\nimport { CHILD_ENV_KEY, CHILD_ENV_VALUE, isChildProcess } from './is-child'\n\nexport type ChildOutput = {\n  exitCode: number | null\n  signal: NodeJS.Signals | null\n}\n\nconst SPAWN_SHELL_ENV: Record<string, string> = {\n  FORCE_COLOR: 'true', // well-known env var used by most shells to enable color output in child processes\n} as const\n\nconst listenForChildSpawn = (child: childProcess.ChildProcess, logger: Logger) =>\n  new Promise<void>((resolve, reject) => {\n    child.on('spawn', () => {\n      logger.debug(`Child process spawned with pid ${child.pid}`)\n      resolve()\n    })\n    child.on('error', (err: Error) => {\n      /**\n       * The 'error' event is emitted whenever:\n       *  - The process could not be spawned.\n       *  - The child process was aborted via the signal option.\n       */\n      logger.debug(`Child process error: ${err.message}`)\n      reject(err)\n    })\n  })\n\nconst listenForChildExit = (child: childProcess.ChildProcess, logger: Logger) =>\n  new Promise<ChildOutput>((resolve, reject) => {\n    child.on('disconnect', () => {\n      logger.debug('Child process disconnected')\n    })\n    child.on('close', (exitCode: number | null, signal: NodeJS.Signals | null) => {\n      /**\n       * this event usually fires after exit unless stdio streams are shared across multiple processes.\n       * see https://stackoverflow.com/questions/37522010/difference-between-childprocess-close-exit-events\n       */\n      logger.debug(`Child process closed with code ${exitCode} and signal ${signal}`)\n    })\n    child.on('exit', (exitCode: number | null, signal: NodeJS.Signals | null) => {\n      logger.debug(`Child process exited with code ${exitCode} and signal ${signal}`)\n      resolve({ exitCode, signal })\n    })\n    child.on('error', (err: Error) => {\n      /**\n       * The 'error' event is emitted whenever:\n       *  - The process could not be killed.\n       *  - The child process was aborted via the signal option.\n       */\n      logger.debug(`Child process error: ${err.message}`)\n      reject(err)\n    })\n    child.on('message', (message) => {\n      logger.debug(`Child process message: ${message}`)\n    })\n  })\n\n/**\n * Wrapper above child_process.ChildProcess to simplify usage\n */\nexport class ChildProcessWrapper {\n  public static async spawn(config: Config, logger: Logger): Promise<ChildProcessWrapper> {\n    if (isChildProcess) {\n      throw new Error('Cannot spawn child process from child process')\n    }\n\n    const child = childProcess.fork(ENTRY_POINT, [], {\n      stdio: 'inherit',\n      env: {\n        ...SPAWN_SHELL_ENV,\n        [CHILD_ENV_KEY]: CHILD_ENV_VALUE,\n        [CONFIG_ENV_KEY]: JSON.stringify(config),\n        ...config.env,\n      },\n    })\n\n    const childSpawnPromise = listenForChildSpawn(child, logger)\n    const childExitPromise = listenForChildExit(child, logger)\n\n    const instance = new ChildProcessWrapper(child, childExitPromise)\n\n    childExitPromise.finally(() => {\n      instance._exited = true\n    })\n\n    await childSpawnPromise\n\n    return instance\n  }\n\n  private _exited = false\n  private constructor(private _child: childProcess.ChildProcess, private _exitPromise: Promise<ChildOutput>) {}\n\n  public async kill(): Promise<ChildOutput> {\n    if (this._exited) {\n      throw new Error('Child process already exited and cannot be killed')\n    }\n    this._child.kill()\n    const res = await this._exitPromise\n    return res\n  }\n\n  public async listen(): Promise<ChildOutput> {\n    if (this._exited) {\n      throw new Error('Child process already exited and cannot be listened on')\n    }\n    const res = await this._exitPromise\n    return res\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAA8B;AAE9B,8BAA4B;AAC5B,oBAAuC;AACvC,sBAA+D;AAO/D,MAAM,kBAA0C;AAAA,EAC9C,aAAa;AACf;AAEA,MAAM,sBAAsB,CAAC,OAAkC,WAC7D,IAAI,QAAc,CAAC,SAAS,WAAW;AACrC,QAAM,GAAG,SAAS,MAAM;AACtB,WAAO,MAAM,kCAAkC,MAAM,KAAK;AAC1D,YAAQ;AAAA,EACV,CAAC;AACD,QAAM,GAAG,SAAS,CAAC,QAAe;AAMhC,WAAO,MAAM,wBAAwB,IAAI,SAAS;AAClD,WAAO,GAAG;AAAA,EACZ,CAAC;AACH,CAAC;AAEH,MAAM,qBAAqB,CAAC,OAAkC,WAC5D,IAAI,QAAqB,CAAC,SAAS,WAAW;AAC5C,QAAM,GAAG,cAAc,MAAM;AAC3B,WAAO,MAAM,4BAA4B;AAAA,EAC3C,CAAC;AACD,QAAM,GAAG,SAAS,CAAC,UAAyB,WAAkC;AAK5E,WAAO,MAAM,kCAAkC,uBAAuB,QAAQ;AAAA,EAChF,CAAC;AACD,QAAM,GAAG,QAAQ,CAAC,UAAyB,WAAkC;AAC3E,WAAO,MAAM,kCAAkC,uBAAuB,QAAQ;AAC9E,YAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,EAC9B,CAAC;AACD,QAAM,GAAG,SAAS,CAAC,QAAe;AAMhC,WAAO,MAAM,wBAAwB,IAAI,SAAS;AAClD,WAAO,GAAG;AAAA,EACZ,CAAC;AACD,QAAM,GAAG,WAAW,CAAC,YAAY;AAC/B,WAAO,MAAM,0BAA0B,SAAS;AAAA,EAClD,CAAC;AACH,CAAC;AAKI,MAAM,oBAAoB;AAAA,EA+BvB,YAAoB,QAA2C,cAAoC;AAA/E;AAA2C;AAAA,EAAqC;AAAA,EA9B5G,aAAoB,MAAM,QAAgB,QAA8C;AACtF,QAAI,gCAAgB;AAClB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,UAAM,QAAQ,aAAa,KAAK,qCAAa,CAAC,GAAG;AAAA,MAC/C,OAAO;AAAA,MACP,KAAK;AAAA,QACH,GAAG;AAAA,QACH,CAAC,gCAAgB;AAAA,QACjB,CAAC,+BAAiB,KAAK,UAAU,MAAM;AAAA,QACvC,GAAG,OAAO;AAAA,MACZ;AAAA,IACF,CAAC;AAED,UAAM,oBAAoB,oBAAoB,OAAO,MAAM;AAC3D,UAAM,mBAAmB,mBAAmB,OAAO,MAAM;AAEzD,UAAM,WAAW,IAAI,oBAAoB,OAAO,gBAAgB;AAEhE,qBAAiB,QAAQ,MAAM;AAC7B,eAAS,UAAU;AAAA,IACrB,CAAC;AAED,UAAM;AAEN,WAAO;AAAA,EACT;AAAA,EAEQ,UAAU;AAAA,EAGlB,MAAa,OAA6B;AACxC,QAAI,KAAK,SAAS;AAChB,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AACA,SAAK,OAAO,KAAK;AACjB,UAAM,MAAM,MAAM,KAAK;AACvB,WAAO;AAAA,EACT;AAAA,EAEA,MAAa,SAA+B;AAC1C,QAAI,KAAK,SAAS;AAChB,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AACA,UAAM,MAAM,MAAM,KAAK;AACvB,WAAO;AAAA,EACT;AACF;",
  "names": []
}
