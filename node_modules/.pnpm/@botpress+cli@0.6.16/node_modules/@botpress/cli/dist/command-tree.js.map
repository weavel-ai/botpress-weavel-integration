{
  "version": 3,
  "sources": ["../src/command-tree.ts"],
  "sourcesContent": ["import type * as typings from './typings'\n\nexport type DefinitionSubTree = {\n  description: string\n  subcommands: DefinitionTree\n}\n\nexport type DefinitionTree = {\n  [key: string]: DefinitionTreeNode\n}\n\nexport type DefinitionTreeNode = typings.CommandDefinition | DefinitionSubTree\n\nexport type ImplementationSubTree<D extends DefinitionSubTree = DefinitionSubTree> = {\n  subcommands: ImplementationTree<D['subcommands']>\n}\n\nexport type ImplementationTreeNode<N extends DefinitionTreeNode = DefinitionTreeNode> =\n  N extends typings.CommandDefinition\n    ? typings.CommandImplementation<N>\n    : N extends DefinitionSubTree\n    ? ImplementationSubTree<N>\n    : never\n\nexport type ImplementationTree<D extends DefinitionTree = DefinitionTree> = {\n  [K in keyof D]: ImplementationTreeNode<D[K]>\n}\n\nexport type CommandSubTree<D extends DefinitionSubTree = DefinitionSubTree> = {\n  description: string\n  subcommands: CommandTree<D['subcommands']>\n}\n\nexport type CommandTreeNode<N extends DefinitionTreeNode = DefinitionTreeNode> = N extends typings.CommandDefinition\n  ? typings.CommandLeaf<N>\n  : N extends DefinitionSubTree\n  ? CommandSubTree<N>\n  : never\n\nexport type CommandTree<D extends DefinitionTree = DefinitionTree> = {\n  [K in keyof D]: CommandTreeNode<D[K]>\n}\n\nexport const guards = {\n  definition: {\n    isDef: (x: DefinitionTreeNode): x is typings.CommandDefinition => 'schema' in x,\n    isSubTree: (x: DefinitionTreeNode): x is DefinitionSubTree => 'subcommands' in x,\n  },\n  implementation: {\n    isImpl: (x: ImplementationTreeNode): x is typings.CommandImplementation => typeof x === 'function',\n    isSubTree: (x: ImplementationTreeNode): x is ImplementationSubTree => typeof x === 'object',\n  },\n  command: {\n    isLeaf: (x: CommandTreeNode): x is typings.CommandLeaf => 'handler' in x,\n    isSubTree: (x: CommandTreeNode): x is CommandSubTree => 'subcommands' in x,\n  },\n}\n\nexport const zipTree = <T extends DefinitionTree>(defTree: T, implTree: ImplementationTree<T>): CommandTree<T> => {\n  const tree = {} as CommandTree<T>\n\n  for (const key in defTree) {\n    const def = defTree[key]!\n    const impl = implTree[key]!\n\n    if (guards.definition.isDef(def) && guards.implementation.isImpl(impl)) {\n      tree[key] = { ...def, handler: impl } as CommandTreeNode<typeof def>\n      continue\n    }\n\n    if (guards.definition.isSubTree(def) && guards.implementation.isSubTree(impl)) {\n      tree[key] = { ...def, subcommands: zipTree(def.subcommands, impl.subcommands) } as CommandTreeNode<typeof def>\n      continue\n    }\n  }\n\n  return tree\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2CO,MAAM,SAAS;AAAA,EACpB,YAAY;AAAA,IACV,OAAO,CAAC,MAA0D,YAAY;AAAA,IAC9E,WAAW,CAAC,MAAkD,iBAAiB;AAAA,EACjF;AAAA,EACA,gBAAgB;AAAA,IACd,QAAQ,CAAC,MAAkE,OAAO,MAAM;AAAA,IACxF,WAAW,CAAC,MAA0D,OAAO,MAAM;AAAA,EACrF;AAAA,EACA,SAAS;AAAA,IACP,QAAQ,CAAC,MAAiD,aAAa;AAAA,IACvE,WAAW,CAAC,MAA4C,iBAAiB;AAAA,EAC3E;AACF;AAEO,MAAM,UAAU,CAA2B,SAAY,aAAoD;AAChH,QAAM,OAAO,CAAC;AAEd,aAAW,OAAO,SAAS;AACzB,UAAM,MAAM,QAAQ;AACpB,UAAM,OAAO,SAAS;AAEtB,QAAI,OAAO,WAAW,MAAM,GAAG,KAAK,OAAO,eAAe,OAAO,IAAI,GAAG;AACtE,WAAK,OAAO,EAAE,GAAG,KAAK,SAAS,KAAK;AACpC;AAAA,IACF;AAEA,QAAI,OAAO,WAAW,UAAU,GAAG,KAAK,OAAO,eAAe,UAAU,IAAI,GAAG;AAC7E,WAAK,OAAO,EAAE,GAAG,KAAK,aAAa,QAAQ,IAAI,aAAa,KAAK,WAAW,EAAE;AAC9E;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;",
  "names": []
}
