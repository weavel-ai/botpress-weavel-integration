"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var register_yargs_exports = {};
__export(register_yargs_exports, {
  registerYargs: () => registerYargs
});
module.exports = __toCommonJS(register_yargs_exports);
var import_yargs_extra = require("@bpinternal/yargs-extra");
var import_lodash = __toESM(require("lodash"));
var tree = __toESM(require("./command-tree"));
const parseArguments = (schema, argv) => {
  const yargsEnv = (0, import_yargs_extra.parseEnv)(schema, "BP");
  return (0, import_yargs_extra.cleanupConfig)(schema, { ...argv, ...yargsEnv });
};
const registerYargs = (yargz, commands) => {
  for (const cmdName in commands) {
    const command = commands[cmdName];
    if (tree.guards.command.isSubTree(command)) {
      yargz.command(cmdName, command.description ?? cmdName, (y) => {
        registerYargs(y, command.subcommands);
        return y;
      });
      continue;
    }
    const { schema, description, alias } = command;
    const aliases = alias ? [cmdName, alias] : [cmdName];
    const options = Object.entries(schema);
    let positionals = options.filter(
      (value) => !!value[1].positional
    );
    let usage = aliases;
    if (positionals.length) {
      positionals = import_lodash.default.sortBy(positionals, ([, option]) => option.idx);
      const positionalArgs = positionals.map(
        ([optName, option]) => option.demandOption ? `<${optName}>` : `[${optName}]`
      );
      const positionalStr = positionalArgs.join(" ");
      usage = aliases.map((optAlias) => `${optAlias} ${positionalStr}`);
    }
    yargz.command(
      usage,
      description ?? cmdName,
      (y) => {
        for (const [key, option] of Object.entries(schema)) {
          if (option.positional) {
            y = y.positional(key, option);
          } else {
            y = y.option(key, option);
          }
        }
        return y;
      },
      async (argv) => {
        const parsed = parseArguments(schema, argv);
        const { exitCode } = await command.handler({ ...parsed });
        process.exit(exitCode);
      }
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  registerYargs
});
//# sourceMappingURL=register-yargs.js.map
