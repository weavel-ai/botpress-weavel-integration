{
  "version": 3,
  "sources": ["../../src/api/client.ts"],
  "sourcesContent": ["import * as client from '@botpress/client'\nimport _ from 'lodash'\nimport { formatIntegrationRef, ApiIntegrationRef as IntegrationRef } from '../integration-ref'\nimport type { Logger } from '../logger'\nimport * as paging from './paging'\n\nexport type PageLister<R extends object> = (t: { nextToken?: string }) => Promise<R & { meta: { nextToken?: string } }>\n\nexport type ApiClientProps = {\n  apiUrl: string\n  token: string\n  workspaceId: string\n}\n\nexport type ApiClientFactory = {\n  newClient: (props: ApiClientProps, logger: Logger) => ApiClient\n}\n\ntype PublicIntegration = client.Integration\ntype PrivateIntegration = client.Integration & { workspaceId: string }\ntype Integration = client.Integration & { workspaceId?: string }\n\n/**\n * This class is used to wrap the Botpress API and provide a more convenient way to interact with it.\n */\nexport class ApiClient {\n  public readonly client: client.Client\n  public readonly url: string\n  public readonly token: string\n  public readonly workspaceId: string\n\n  public static newClient = (props: ApiClientProps, logger: Logger) => new ApiClient(props, logger)\n\n  public constructor(props: ApiClientProps, private _logger: Logger) {\n    const { apiUrl, token, workspaceId } = props\n    this.client = new client.Client({ apiUrl, token, workspaceId })\n    this.url = apiUrl\n    this.token = token\n    this.workspaceId = workspaceId\n  }\n\n  public async findIntegration(ref: IntegrationRef): Promise<Integration | undefined> {\n    const formatted = formatIntegrationRef(ref)\n\n    const privateIntegration = await this.findPrivateIntegration(ref)\n    if (privateIntegration) {\n      this._logger.debug(`Found integration \"${formatted}\" in workspace`)\n      return privateIntegration\n    }\n\n    const publicIntegration = await this.findPublicIntegration(ref)\n    if (publicIntegration) {\n      this._logger.debug(`Found integration \"${formatted}\" in hub`)\n      return publicIntegration\n    }\n\n    return\n  }\n\n  public async findPrivateIntegration(ref: IntegrationRef): Promise<PrivateIntegration | undefined> {\n    const { workspaceId } = this\n    if (ref.type === 'id') {\n      return this.validateStatus(\n        () => this.client.getIntegration(ref).then((r) => ({ ...r.integration, workspaceId })),\n        404\n      )\n    }\n    return this.validateStatus(\n      () => this.client.getIntegrationByName(ref).then((r) => ({ ...r.integration, workspaceId })),\n      404\n    )\n  }\n\n  public async findPublicIntegration(ref: IntegrationRef): Promise<PublicIntegration | undefined> {\n    if (ref.type === 'id') {\n      return this.validateStatus(() => this.client.getPublicIntegrationById(ref).then((r) => r.integration), 404)\n    }\n    return this.validateStatus(() => this.client.getPublicIntegration(ref).then((r) => r.integration), 404)\n  }\n\n  public async testLogin(): Promise<void> {\n    await this.client.listBots({})\n  }\n\n  public listAllPages = paging.listAllPages\n\n  public async validateStatus<V>(fn: () => Promise<V>, allowedStatuses: number | number[]): Promise<V | undefined> {\n    try {\n      const v = await fn()\n      return v\n    } catch (err) {\n      const allowedStatusesArray = _.isArray(allowedStatuses) ? allowedStatuses : [allowedStatuses]\n      const isAllowed = client.isApiError(err) && err.code && allowedStatusesArray.includes(err.code)\n      if (isAllowed) {\n        return\n      }\n      throw err\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAAwB;AACxB,oBAAc;AACd,6BAA0E;AAE1E,aAAwB;AAqBjB,MAAM,UAAU;AAAA,EAQd,YAAY,OAA+B,SAAiB;AAAjB;AAChD,UAAM,EAAE,QAAQ,OAAO,YAAY,IAAI;AACvC,SAAK,SAAS,IAAI,OAAO,OAAO,EAAE,QAAQ,OAAO,YAAY,CAAC;AAC9D,SAAK,MAAM;AACX,SAAK,QAAQ;AACb,SAAK,cAAc;AAAA,EACrB;AAAA,EAbgB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEhB,OAAc,YAAY,CAAC,OAAuB,WAAmB,IAAI,UAAU,OAAO,MAAM;AAAA,EAUhG,MAAa,gBAAgB,KAAuD;AAClF,UAAM,gBAAY,6CAAqB,GAAG;AAE1C,UAAM,qBAAqB,MAAM,KAAK,uBAAuB,GAAG;AAChE,QAAI,oBAAoB;AACtB,WAAK,QAAQ,MAAM,sBAAsB,yBAAyB;AAClE,aAAO;AAAA,IACT;AAEA,UAAM,oBAAoB,MAAM,KAAK,sBAAsB,GAAG;AAC9D,QAAI,mBAAmB;AACrB,WAAK,QAAQ,MAAM,sBAAsB,mBAAmB;AAC5D,aAAO;AAAA,IACT;AAEA;AAAA,EACF;AAAA,EAEA,MAAa,uBAAuB,KAA8D;AAChG,UAAM,EAAE,YAAY,IAAI;AACxB,QAAI,IAAI,SAAS,MAAM;AACrB,aAAO,KAAK;AAAA,QACV,MAAM,KAAK,OAAO,eAAe,GAAG,EAAE,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE,aAAa,YAAY,EAAE;AAAA,QACrF;AAAA,MACF;AAAA,IACF;AACA,WAAO,KAAK;AAAA,MACV,MAAM,KAAK,OAAO,qBAAqB,GAAG,EAAE,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE,aAAa,YAAY,EAAE;AAAA,MAC3F;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAa,sBAAsB,KAA6D;AAC9F,QAAI,IAAI,SAAS,MAAM;AACrB,aAAO,KAAK,eAAe,MAAM,KAAK,OAAO,yBAAyB,GAAG,EAAE,KAAK,CAAC,MAAM,EAAE,WAAW,GAAG,GAAG;AAAA,IAC5G;AACA,WAAO,KAAK,eAAe,MAAM,KAAK,OAAO,qBAAqB,GAAG,EAAE,KAAK,CAAC,MAAM,EAAE,WAAW,GAAG,GAAG;AAAA,EACxG;AAAA,EAEA,MAAa,YAA2B;AACtC,UAAM,KAAK,OAAO,SAAS,CAAC,CAAC;AAAA,EAC/B;AAAA,EAEO,eAAe,OAAO;AAAA,EAE7B,MAAa,eAAkB,IAAsB,iBAA4D;AAC/G,QAAI;AACF,YAAM,IAAI,MAAM,GAAG;AACnB,aAAO;AAAA,IACT,SAAS,KAAP;AACA,YAAM,uBAAuB,cAAAA,QAAE,QAAQ,eAAe,IAAI,kBAAkB,CAAC,eAAe;AAC5F,YAAM,YAAY,OAAO,WAAW,GAAG,KAAK,IAAI,QAAQ,qBAAqB,SAAS,IAAI,IAAI;AAC9F,UAAI,WAAW;AACb;AAAA,MACF;AACA,YAAM;AAAA,IACR;AAAA,EACF;AACF;",
  "names": ["_"]
}
