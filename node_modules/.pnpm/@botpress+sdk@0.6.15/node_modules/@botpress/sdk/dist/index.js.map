{
  "version": 3,
  "sources": ["../src/index.ts", "../src/message.ts", "../src/const.ts", "../src/serve.ts", "../src/log.ts", "../src/integration/context.ts", "../src/integration/definition.ts", "../src/integration/server.ts", "../src/integration/client/index.ts", "../src/integration/logger.ts", "../src/integration/implementation.ts", "../src/bot/server.ts", "../src/bot/client/index.ts", "../src/bot/context.ts", "../src/bot/implementation.ts"],
  "sourcesContent": ["export * as messages from './message'\nexport * from './const'\nexport * from './serve'\n\nexport {\n  IntegrationDefinition,\n  IntegrationDefinitionProps,\n  IntegrationImplementation as Integration,\n  IntegrationImplementationProps as IntegrationProps,\n  IntegrationContext,\n  IntegrationSpecificClient,\n} from './integration'\n\nexport { Bot, BotProps, BotContext, BotSpecificClient, IntegrationInstance } from './bot'\n\n/**\n * @deprecated Infer type of integration message handlers instead\n */\nexport type AckFunction = (props: { tags: Record<string, string> }) => Promise<void>\n", "import { z } from 'zod'\n\nconst NonEmptyString = z.string().min(1)\n\nconst textMessageSchema = z.object({\n  text: NonEmptyString,\n})\n\nconst markdownMessageSchema = z.object({\n  markdown: NonEmptyString,\n})\n\nconst imageMessageSchema = z.object({\n  imageUrl: NonEmptyString,\n})\n\nconst audioMessageSchema = z.object({\n  audioUrl: NonEmptyString,\n})\n\nconst videoMessageSchema = z.object({\n  videoUrl: NonEmptyString,\n})\n\nconst fileMessageSchema = z.object({\n  fileUrl: NonEmptyString,\n  title: NonEmptyString.optional(),\n})\n\nconst locationMessageSchema = z.object({\n  latitude: z.number(),\n  longitude: z.number(),\n  address: z.string().optional(),\n  title: z.string().optional(),\n})\n\nconst cardSchema = z.object({\n  title: NonEmptyString,\n  subtitle: NonEmptyString.optional(),\n  imageUrl: NonEmptyString.optional(),\n  actions: z.array(\n    z.object({\n      action: z.enum(['postback', 'url', 'say']),\n      label: NonEmptyString,\n      value: NonEmptyString,\n    })\n  ),\n})\n\nconst choiceSchema = z.object({\n  text: NonEmptyString,\n  options: z.array(\n    z.object({\n      label: NonEmptyString,\n      value: NonEmptyString,\n    })\n  ),\n})\n\nconst carouselSchema = z.object({\n  items: z.array(cardSchema),\n})\n\nexport const defaults = {\n  text: { schema: textMessageSchema },\n  markdown: { schema: markdownMessageSchema },\n  image: { schema: imageMessageSchema },\n  audio: { schema: audioMessageSchema },\n  video: { schema: videoMessageSchema },\n  file: { schema: fileMessageSchema },\n  location: { schema: locationMessageSchema },\n  carousel: { schema: carouselSchema },\n  card: { schema: cardSchema },\n  dropdown: { schema: choiceSchema },\n  choice: { schema: choiceSchema },\n} as const // should use satisfies operator but this works for older versions of TS\n", "export const botIdHeader = 'x-bot-id'\nexport const botUserIdHeader = 'x-bot-user-id'\nexport const integrationIdHeader = 'x-integration-id'\nexport const webhookIdHeader = 'x-webhook-id'\n\nexport const configurationHeader = 'x-bp-configuration'\nexport const operationHeader = 'x-bp-operation'\nexport const typeHeader = 'x-bp-type'\n", "import { createServer, IncomingMessage, Server } from 'node:http'\nimport { log } from './log'\n\nexport type Request = {\n  body?: string\n  path: string\n  query: string\n  method: string\n  headers: { [key: string]: string | undefined }\n}\n\nexport type Response = {\n  body?: string\n  headers?: { [key: string]: string }\n  status?: number\n}\n\nexport type Handler = (req: Request) => Promise<Response | void>\n\nexport function parseBody<T>(req: Request): T {\n  if (!req.body) {\n    throw new Error('Missing body')\n  }\n  return JSON.parse(req.body)\n}\n\nexport async function serve(\n  handler: Handler,\n  port: number = 8072,\n  callback: (port: number) => void = defaultCallback\n): Promise<Server> {\n  /* eslint-disable @typescript-eslint/no-misused-promises */\n  const server = createServer(async (req, res) => {\n    try {\n      const request = await mapIncomingMessageToRequest(req)\n      if (request.path === '/health') {\n        res.writeHead(200).end('ok')\n        return\n      }\n      const response = await handler(request)\n      res.writeHead(response?.status ?? 200, response?.headers ?? {}).end(response?.body ?? '{}')\n    } catch (e: any) {\n      log.error('Error while handling request', { error: e?.message ?? 'Internal error occured' })\n      res.writeHead(500).end(JSON.stringify({ error: e?.message ?? 'Internal error occured' }))\n    }\n  })\n\n  server.listen(port, () => callback(port))\n  return server\n}\n\nasync function mapIncomingMessageToRequest(incoming: IncomingMessage): Promise<Request> {\n  const body = await readBody(incoming)\n  const headers = {} as Request['headers']\n\n  for (let i = 0; i < incoming.rawHeaders.length; i += 2) {\n    const key = incoming.rawHeaders[i]!.toLowerCase()\n    const value = incoming.rawHeaders[i + 1]!\n    headers[key] = value\n  }\n\n  const url = new URL(\n    incoming.url ?? '',\n    incoming.headers.host ? `http://${incoming.headers.host}` : 'http://botpress.cloud'\n  )\n\n  return {\n    body,\n    path: url.pathname,\n    query: trimPrefix(url.search, '?'),\n    headers,\n    method: incoming.method?.toUpperCase() ?? 'GET',\n  }\n}\n\nfunction trimPrefix(value: string, prefix: string) {\n  return value.indexOf(prefix) === 0 ? value.slice(prefix.length) : value\n}\n\nasync function readBody(incoming: IncomingMessage) {\n  return new Promise<string | undefined>((resolve, reject) => {\n    if (incoming.method !== 'POST' && incoming.method !== 'PUT' && incoming.method !== 'PATCH') {\n      return resolve(undefined)\n    }\n\n    let body = ''\n\n    incoming.on('data', (chunk) => (body += chunk.toString()))\n    incoming.on('error', (e) => reject(e))\n    incoming.on('end', () => resolve(body))\n  })\n}\n\nfunction defaultCallback(port: number) {\n  log.info(`Listening on port ${port}`)\n}\n", "export type Logger = {\n  debug(message: string, metadata?: any): void\n  info(message: string, metadata?: any): void\n  warn(message: string, metadata?: any): void\n  error(message: string, metadata?: any): void\n}\nexport const log: Logger = console\n", "import { z } from 'zod'\nimport {\n  botIdHeader,\n  botUserIdHeader,\n  configurationHeader,\n  integrationIdHeader,\n  operationHeader,\n  webhookIdHeader,\n} from '../const'\n\nexport const integrationOperationSchema = z.enum([\n  'webhook_received',\n  'message_created',\n  'action_triggered',\n  'register',\n  'unregister',\n  'ping',\n  'create_user',\n  'create_conversation',\n])\n\nexport type IntegrationOperation = z.infer<typeof integrationOperationSchema>\n\nexport type IntegrationContext<Configuration = any> = {\n  botId: string\n  botUserId: string\n  integrationId: string\n  webhookId: string\n  operation: IntegrationOperation\n  configuration: Configuration\n}\n\nexport const extractContext = (headers: Record<string, string | undefined>): IntegrationContext => {\n  const botId = headers[botIdHeader]\n  const botUserId = headers[botUserIdHeader]\n  const integrationId = headers[integrationIdHeader]\n  const webhookId = headers[webhookIdHeader]\n  const base64Configuration = headers[configurationHeader]\n  const operation = integrationOperationSchema.parse(headers[operationHeader])\n\n  if (!botId) {\n    throw new Error('Missing bot headers')\n  }\n\n  if (!botUserId) {\n    throw new Error('Missing bot user headers')\n  }\n\n  if (!integrationId) {\n    throw new Error('Missing integration headers')\n  }\n\n  if (!webhookId) {\n    throw new Error('Missing webhook headers')\n  }\n\n  if (!base64Configuration) {\n    throw new Error('Missing configuration headers')\n  }\n\n  if (!operation) {\n    throw new Error('Missing operation headers')\n  }\n\n  return {\n    botId,\n    botUserId,\n    integrationId,\n    webhookId,\n    operation,\n    configuration: base64Configuration ? JSON.parse(Buffer.from(base64Configuration, 'base64').toString('utf-8')) : {},\n  }\n}\n", "import { SchemaDefinition } from '../schema'\nimport { AnyZodObject } from '../type-utils'\n\ntype BaseConfig = AnyZodObject\ntype BaseEvents = Record<string, AnyZodObject>\ntype BaseActions = Record<string, AnyZodObject>\ntype BaseChannels = Record<string, Record<string, AnyZodObject>>\ntype BaseStates = Record<string, AnyZodObject>\ntype BaseEntities = Record<string, AnyZodObject>\n\ntype TagDefinition = {\n  title?: string\n  description?: string\n}\n\ntype ConfigurationDefinition<TConfig extends BaseConfig> = SchemaDefinition<TConfig> & {\n  identifier?: {\n    required?: boolean\n    linkTemplateScript?: string\n  }\n}\n\ntype EventDefinition<TEvent extends BaseEvents[string]> = SchemaDefinition<TEvent> & {\n  title?: string\n  description?: string\n}\n\ntype ChannelDefinition<TChannel extends BaseChannels[string]> = {\n  title?: string\n  description?: string\n  messages: {\n    [K in keyof TChannel]: SchemaDefinition<TChannel[K]>\n  }\n  message?: {\n    tags?: Record<string, TagDefinition>\n  }\n  conversation?: Partial<{\n    tags: Record<string, TagDefinition>\n    /**\n     * @deprecated\n     */\n    creation: {\n      enabled: boolean\n      requiredTags: string[]\n    }\n  }>\n}\n\ntype ActionDefinition<TAction extends BaseActions[string]> = {\n  title?: string\n  description?: string\n  input: SchemaDefinition<TAction>\n  output: SchemaDefinition<AnyZodObject> // cannot infer both input and output types (typescript limitation)\n}\n\ntype StateDefinition<TState extends BaseStates[string]> = SchemaDefinition<TState> & {\n  type: 'integration' | 'conversation' | 'user'\n}\n\ntype UserDefinition = Partial<{\n  tags: Record<string, TagDefinition>\n  /**\n   * @deprecated\n   */\n  creation: {\n    enabled: boolean\n    requiredTags: string[]\n  }\n}>\n\ntype SecretDefinition = {\n  optional?: boolean\n  description?: string\n}\n\ntype EntityDefinition<TEntity extends BaseEntities[string]> = SchemaDefinition<TEntity> & {\n  title?: string\n  description?: string\n}\n\nexport type IntegrationDefinitionProps<\n  TConfig extends BaseConfig = BaseConfig,\n  TEvents extends BaseEvents = BaseEvents,\n  TActions extends BaseActions = BaseActions,\n  TChannels extends BaseChannels = BaseChannels,\n  TStates extends BaseStates = BaseStates,\n  TEntities extends BaseEntities = BaseEntities\n> = {\n  name: string\n  version: string\n\n  title?: string\n  description?: string\n  icon?: string\n  readme?: string\n\n  identifier?: {\n    extractScript?: string\n    fallbackHandlerScript?: string\n  }\n\n  configuration?: ConfigurationDefinition<TConfig>\n  events?: { [K in keyof TEvents]: EventDefinition<TEvents[K]> }\n\n  actions?: {\n    [K in keyof TActions]: ActionDefinition<TActions[K]>\n  }\n\n  channels?: {\n    [K in keyof TChannels]: ChannelDefinition<TChannels[K]>\n  }\n\n  states?: {\n    [K in keyof TStates]: StateDefinition<TStates[K]>\n  }\n\n  user?: UserDefinition\n\n  secrets?: Record<string, SecretDefinition>\n\n  entities?: {\n    [K in keyof TEntities]: EntityDefinition<TEntities[K]>\n  }\n}\n\nexport class IntegrationDefinition<\n  TConfig extends BaseConfig = BaseConfig,\n  TEvents extends BaseEvents = BaseEvents,\n  TActions extends BaseActions = BaseActions,\n  TChannels extends BaseChannels = BaseChannels,\n  TStates extends BaseStates = BaseStates,\n  TEntities extends BaseEntities = BaseEntities\n> {\n  public readonly name: this['props']['name']\n  public readonly version: this['props']['version']\n  public readonly title: this['props']['title']\n  public readonly description: this['props']['description']\n  public readonly icon: this['props']['icon']\n  public readonly readme: this['props']['readme']\n  public readonly configuration: this['props']['configuration']\n  public readonly events: this['props']['events']\n  public readonly actions: this['props']['actions']\n  public readonly channels: this['props']['channels']\n  public readonly states: this['props']['states']\n  public readonly user: this['props']['user']\n  public readonly secrets: this['props']['secrets']\n  public readonly identifier: this['props']['identifier']\n  public readonly entities: this['props']['entities']\n\n  public constructor(\n    public readonly props: IntegrationDefinitionProps<TConfig, TEvents, TActions, TChannels, TStates, TEntities>\n  ) {\n    this.name = props.name\n    this.version = props.version\n    this.icon = props.icon\n    this.readme = props.readme\n    this.title = props.title\n    this.identifier = props.identifier\n    this.description = props.description\n    this.configuration = props.configuration\n    this.events = props.events\n    this.actions = props.actions\n    this.channels = props.channels\n    this.states = props.states\n    this.user = props.user\n    this.secrets = props.secrets\n    this.entities = props.entities\n  }\n}\n", "import { Client, RuntimeError, type Conversation, type Message, type User } from '@botpress/client'\nimport { Request, Response, parseBody } from '../serve'\nimport { Cast, Merge } from '../type-utils'\nimport { IntegrationSpecificClient } from './client'\nimport { ToTags } from './client/types'\nimport { extractContext, type IntegrationContext } from './context'\nimport { BaseIntegration } from './generic'\nimport { IntegrationLogger, integrationLogger } from './logger'\n\ntype PrefixConfig<TIntegration extends BaseIntegration> = { enforcePrefix: TIntegration['name'] }\n\ntype CommonArgs<TIntegration extends BaseIntegration> = {\n  ctx: IntegrationContext<TIntegration['configuration']>\n  client: IntegrationSpecificClient<TIntegration>\n  logger: IntegrationLogger\n}\n\ntype RegisterPayload = { webhookUrl: string }\ntype RegisterArgs<TIntegration extends BaseIntegration> = CommonArgs<TIntegration> & RegisterPayload\n\ntype UnregisterPayload = { webhookUrl: string }\ntype UnregisterArgs<TIntegration extends BaseIntegration> = CommonArgs<TIntegration> & UnregisterPayload\n\ntype WebhookPayload = { req: Request }\ntype WebhookArgs<TIntegration extends BaseIntegration> = CommonArgs<TIntegration> & WebhookPayload\n\ntype ActionPayload<T extends string, I> = { type: T; input: I }\ntype ActionArgs<TIntegration extends BaseIntegration, T extends string, I> = CommonArgs<TIntegration> &\n  ActionPayload<T, I>\n\ntype CreateUserPayload<TIntegration extends BaseIntegration> = {\n  tags: ToTags<keyof TIntegration['user']['tags'], PrefixConfig<TIntegration>>\n}\ntype CreateUserArgs<TIntegration extends BaseIntegration> = CommonArgs<TIntegration> & CreateUserPayload<TIntegration>\n\ntype CreateConversationPayload<\n  TIntegration extends BaseIntegration,\n  TChannel extends keyof TIntegration['channels'] = keyof TIntegration['channels']\n> = {\n  channel: TChannel\n  tags: ToTags<keyof TIntegration['channels'][TChannel]['conversation']['tags'], PrefixConfig<TIntegration>>\n}\ntype CreateConversationArgs<TIntegration extends BaseIntegration> = CommonArgs<TIntegration> &\n  CreateConversationPayload<TIntegration>\n\ntype MessagePayload<\n  TIntegration extends BaseIntegration,\n  TChannel extends keyof TIntegration['channels'],\n  TMessage extends keyof TIntegration['channels'][TChannel]['messages']\n> = {\n  type: TMessage\n  payload: TIntegration['channels'][TChannel]['messages'][TMessage]\n  conversation: Merge<\n    Conversation,\n    {\n      tags: ToTags<keyof TIntegration['channels'][TChannel]['conversation']['tags'], PrefixConfig<TIntegration>>\n    }\n  >\n  message: Merge<\n    Message,\n    {\n      tags: ToTags<keyof TIntegration['channels'][TChannel]['message']['tags'], PrefixConfig<TIntegration>>\n    }\n  >\n  user: Merge<\n    User,\n    {\n      tags: ToTags<keyof TIntegration['user']['tags'], PrefixConfig<TIntegration>>\n    }\n  >\n}\ntype MessageArgs<\n  TIntegration extends BaseIntegration,\n  TChannel extends keyof TIntegration['channels'],\n  TMessage extends keyof TIntegration['channels'][TChannel]['messages']\n> = CommonArgs<TIntegration> &\n  MessagePayload<TIntegration, TChannel, TMessage> & {\n    ack: (props: {\n      tags: ToTags<keyof TIntegration['channels'][TChannel]['message']['tags'], PrefixConfig<TIntegration>>\n    }) => Promise<void>\n  }\n\nexport type RegisterFunction<TIntegration extends BaseIntegration> = (\n  props: RegisterArgs<TIntegration>\n) => Promise<void>\n\nexport type UnregisterFunction<TIntegration extends BaseIntegration> = (\n  props: UnregisterArgs<TIntegration>\n) => Promise<void>\n\nexport type WebhookFunction<TIntegration extends BaseIntegration> = (\n  props: WebhookArgs<TIntegration>\n) => Promise<Response | void>\n\nexport type ActionFunctions<TIntegration extends BaseIntegration> = {\n  [ActionType in keyof TIntegration['actions']]: (\n    props: ActionArgs<TIntegration, Cast<ActionType, string>, TIntegration['actions'][ActionType]['input']>\n  ) => Promise<TIntegration['actions'][ActionType]['output']>\n}\n\nexport type CreateUserFunction<TIntegration extends BaseIntegration> = (\n  props: CreateUserArgs<TIntegration>\n) => Promise<Response | void>\n\nexport type CreateConversationFunction<TIntegration extends BaseIntegration> = (\n  props: CreateConversationArgs<TIntegration>\n) => Promise<Response | void>\n\nexport type ChannelFunctions<TIntegration extends BaseIntegration> = {\n  [ChannelName in keyof TIntegration['channels']]: {\n    messages: {\n      [MessageType in keyof TIntegration['channels'][ChannelName]['messages']]: (\n        props: CommonArgs<TIntegration> & MessageArgs<TIntegration, ChannelName, MessageType>\n      ) => Promise<void>\n    }\n  }\n}\n\nexport type IntegrationHandlers<TIntegration extends BaseIntegration> = {\n  register: RegisterFunction<TIntegration>\n  unregister: UnregisterFunction<TIntegration>\n  webhook: WebhookFunction<TIntegration>\n  createUser?: CreateUserFunction<TIntegration>\n  createConversation?: CreateConversationFunction<TIntegration>\n  actions: ActionFunctions<TIntegration>\n  channels: ChannelFunctions<TIntegration>\n}\n\ntype ServerProps<TIntegration extends BaseIntegration> = CommonArgs<TIntegration> & {\n  req: Request\n  instance: IntegrationHandlers<TIntegration>\n}\n\nexport const integrationHandler =\n  <TIntegration extends BaseIntegration>(instance: IntegrationHandlers<TIntegration>) =>\n  async (req: Request): Promise<Response | void> => {\n    const ctx = extractContext(req.headers)\n\n    const client = new IntegrationSpecificClient<TIntegration>(\n      new Client({ botId: ctx.botId, integrationId: ctx.integrationId })\n    )\n\n    const props = {\n      ctx,\n      req,\n      client,\n      logger: integrationLogger,\n      instance,\n    }\n\n    try {\n      let response: Response | void\n      switch (ctx.operation) {\n        case 'webhook_received':\n          response = await onWebhook<TIntegration>(props)\n          break\n        case 'register':\n          response = await onRegister<TIntegration>(props)\n          break\n        case 'unregister':\n          response = await onUnregister<TIntegration>(props)\n          break\n        case 'message_created':\n          response = await onMessageCreated<TIntegration>(props)\n          break\n        case 'action_triggered':\n          response = await onActionTriggered<TIntegration>(props)\n          break\n        case 'ping':\n          response = await onPing<TIntegration>(props)\n          break\n        case 'create_user':\n          response = await onCreateUser<TIntegration>(props)\n          break\n        case 'create_conversation':\n          response = await onCreateConversation<TIntegration>(props)\n          break\n        default:\n          throw new Error(`Unknown operation ${ctx.operation}`)\n      }\n      return response ? { ...response, status: response.status ?? 200 } : { status: 200 }\n    } catch (e) {\n      if (e instanceof RuntimeError) {\n        return { status: e.code, body: JSON.stringify(e.toJSON()) }\n      } else {\n        throw e\n      }\n    }\n  }\n\nconst onPing = async <TIntegration extends BaseIntegration>(_: ServerProps<TIntegration>) => {}\n\nconst onWebhook = async <TIntegration extends BaseIntegration>({\n  client,\n  ctx,\n  req: incomingRequest,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  const { req } = parseBody<WebhookPayload>(incomingRequest)\n  return instance.webhook({ client, ctx, req, logger })\n}\n\nconst onRegister = async <TIntegration extends BaseIntegration>({\n  client,\n  ctx,\n  req,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  if (!instance.register) {\n    return\n  }\n  const { webhookUrl } = parseBody<RegisterPayload>(req)\n  await instance.register({ client, ctx, webhookUrl, logger })\n}\n\nconst onUnregister = async <TIntegration extends BaseIntegration>({\n  client,\n  ctx,\n  req,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  if (!instance.unregister) {\n    return\n  }\n  const { webhookUrl } = parseBody<UnregisterPayload>(req)\n  await instance.unregister({ ctx, webhookUrl, client, logger })\n}\n\nconst onCreateUser = async <TIntegration extends BaseIntegration>({\n  client,\n  ctx,\n  req,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  if (!instance.createUser) {\n    return\n  }\n  const { tags } = parseBody<CreateUserPayload<TIntegration>>(req)\n  return await instance.createUser({ ctx, client, tags, logger })\n}\n\nconst onCreateConversation = async <TIntegration extends BaseIntegration>({\n  client,\n  ctx,\n  req,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  if (!instance.createConversation) {\n    return\n  }\n  const { channel, tags } = parseBody<CreateConversationPayload<TIntegration>>(req)\n  return await instance.createConversation({ ctx, client, channel, tags, logger })\n}\n\nconst onMessageCreated = async <TIntegration extends BaseIntegration>({\n  ctx,\n  req,\n  client,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  const { conversation, user, type, payload, message } = parseBody<MessagePayload<TIntegration, string, string>>(req)\n\n  const channelHandler = instance.channels[conversation.channel]\n\n  if (!channelHandler) {\n    throw new Error(`Channel ${conversation.channel} not found`)\n  }\n\n  const messageHandler = channelHandler.messages[type]\n\n  if (!messageHandler) {\n    throw new Error(`Message of type ${type} not found in channel ${conversation.channel}`)\n  }\n\n  const ack = async ({ tags }: { tags: Record<string, string> }) => {\n    await client.updateMessage({\n      id: message.id,\n      tags: tags as any, // TODO: fix this\n    })\n  }\n\n  await messageHandler({ ctx, conversation, message, user, type, client, payload, ack, logger })\n}\n\nconst onActionTriggered = async <TIntegration extends BaseIntegration>({\n  req,\n  ctx,\n  client,\n  logger,\n  instance,\n}: ServerProps<TIntegration>) => {\n  const { input, type } = parseBody<ActionPayload<string, any>>(req)\n\n  if (!type) {\n    throw new Error('Missing action type')\n  }\n\n  const action = instance.actions[type]\n\n  if (!action) {\n    throw new Error(`Action ${type} not found`)\n  }\n\n  const output = await action({ ctx, input, client, type, logger })\n\n  return {\n    body: JSON.stringify({ output }),\n  }\n}\n", "import { Client } from '@botpress/client'\nimport { BaseIntegration } from '../generic'\nimport * as routes from './routes'\n\n/**\n * Just like the regular botpress client, but typed with the integration's properties.\n */\nexport class IntegrationSpecificClient<TIntegration extends BaseIntegration> {\n  public constructor(private readonly client: Client) {}\n\n  public createConversation: routes.CreateConversation<TIntegration> = ((x) =>\n    this.client.createConversation(x)) as routes.CreateConversation<TIntegration>\n  public getConversation: routes.GetConversation<TIntegration> = ((x) =>\n    this.client.getConversation(x)) as routes.GetConversation<TIntegration>\n  public listConversations: routes.ListConversations<TIntegration> = ((x) =>\n    this.client.listConversations(x)) as routes.ListConversations<TIntegration>\n  public getOrCreateConversation: routes.GetOrCreateConversation<TIntegration> = ((x) =>\n    this.client.getOrCreateConversation(x)) as routes.GetOrCreateConversation<TIntegration>\n  public updateConversation: routes.UpdateConversation<TIntegration> = ((x) =>\n    this.client.updateConversation(x)) as routes.UpdateConversation<TIntegration>\n  public deleteConversation: routes.DeleteConversation<TIntegration> = ((x) =>\n    this.client.deleteConversation(x)) as routes.DeleteConversation<TIntegration>\n\n  public listParticipants: routes.ListParticipants<TIntegration> = ((x) =>\n    this.client.listParticipants(x)) as routes.ListParticipants<TIntegration>\n  public addParticipant: routes.AddParticipant<TIntegration> = ((x) =>\n    this.client.addParticipant(x)) as routes.AddParticipant<TIntegration>\n  public getParticipant: routes.GetParticipant<TIntegration> = ((x) =>\n    this.client.getParticipant(x)) as routes.GetParticipant<TIntegration>\n  public removeParticipant: routes.RemoveParticipant<TIntegration> = ((x) =>\n    this.client.removeParticipant(x)) as routes.RemoveParticipant<TIntegration>\n\n  public createEvent: routes.CreateEvent<TIntegration> = ((x) =>\n    this.client.createEvent(x)) as routes.CreateEvent<TIntegration>\n  public getEvent: routes.GetEvent<TIntegration> = ((x) => this.client.getEvent(x)) as routes.GetEvent<TIntegration>\n  public listEvents: routes.ListEvents<TIntegration> = ((x) =>\n    this.client.listEvents(x)) as routes.ListEvents<TIntegration>\n\n  public createMessage: routes.CreateMessage<TIntegration> = ((x) =>\n    this.client.createMessage(x)) as routes.CreateMessage<TIntegration>\n  public getOrCreateMessage: routes.GetOrCreateMessage<TIntegration> = ((x) =>\n    this.client.getOrCreateMessage(x)) as routes.GetOrCreateMessage<TIntegration>\n  public getMessage: routes.GetMessage<TIntegration> = ((x) =>\n    this.client.getMessage(x)) as routes.GetMessage<TIntegration>\n  public updateMessage: routes.UpdateMessage<TIntegration> = ((x) =>\n    this.client.updateMessage(x)) as routes.UpdateMessage<TIntegration>\n  public listMessages: routes.ListMessages<TIntegration> = ((x) =>\n    this.client.listMessages(x)) as routes.ListMessages<TIntegration>\n  public deleteMessage: routes.DeleteMessage<TIntegration> = ((x) =>\n    this.client.deleteMessage(x)) as routes.DeleteMessage<TIntegration>\n\n  public createUser: routes.CreateUser<TIntegration> = ((x) =>\n    this.client.createUser(x)) as routes.CreateUser<TIntegration>\n  public getUser: routes.GetUser<TIntegration> = ((x) => this.client.getUser(x)) as routes.GetUser<TIntegration>\n  public listUsers: routes.ListUsers<TIntegration> = (x) => this.client.listUsers(x)\n  public getOrCreateUser: routes.GetOrCreateUser<TIntegration> = ((x) =>\n    this.client.getOrCreateUser(x)) as routes.GetOrCreateUser<TIntegration>\n  public updateUser: routes.UpdateUser<TIntegration> = ((x) =>\n    this.client.updateUser(x)) as routes.UpdateUser<TIntegration>\n  public deleteUser: routes.DeleteUser<TIntegration> = (x) => this.client.deleteUser(x)\n\n  public getState: routes.GetState<TIntegration> = ((x) => this.client.getState(x)) as routes.GetState<TIntegration>\n  public setState: routes.SetState<TIntegration> = ((x) => this.client.setState(x)) as routes.SetState<TIntegration>\n  public getOrSetState: routes.GetOrSetState<TIntegration> = ((x) =>\n    this.client.getOrSetState(x)) as routes.GetOrSetState<TIntegration>\n  public patchState: routes.PatchState<TIntegration> = ((x) =>\n    this.client.patchState(x)) as routes.PatchState<TIntegration>\n\n  public configureIntegration: routes.ConfigureIntegration<TIntegration> = (x) => this.client.configureIntegration(x)\n}\n", "/* eslint-disable no-console */\nimport util from 'util'\n\nconst serializeForBotMessage = (args: Parameters<typeof util.format>) => {\n  if (process.env['BP_LOG_FORMAT'] === 'json') {\n    return JSON.stringify({ msg: util.format(...args), visible_to_bot_owner: true })\n  } else {\n    const [format, ...param] = args\n    return util.format(`[For Bot Owner] ${format}`, ...param)\n  }\n}\n\nexport const integrationLogger = {\n  /**\n   * Use this function to log messages that will be displayed to the Bot Owner.\n   */\n  forBot: () => {\n    return {\n      info: (...args: Parameters<typeof console.info>) => {\n        console.info(serializeForBotMessage(args))\n      },\n      warn: (...args: Parameters<typeof console.warn>) => {\n        console.warn(serializeForBotMessage(args))\n      },\n      error: (...args: Parameters<typeof console.error>) => {\n        console.error(serializeForBotMessage(args))\n      },\n      debug: (...args: Parameters<typeof console.debug>) => {\n        console.debug(serializeForBotMessage(args))\n      },\n    }\n  },\n}\n\nexport type IntegrationLogger = typeof integrationLogger\n", "import type { Server } from 'node:http'\nimport { serve } from '../serve'\nimport { BaseIntegration } from './generic'\nimport {\n  RegisterFunction,\n  UnregisterFunction,\n  WebhookFunction,\n  CreateUserFunction,\n  CreateConversationFunction,\n  ActionFunctions,\n  ChannelFunctions,\n  integrationHandler,\n} from './server'\n\nexport type IntegrationImplementationProps<TIntegration extends BaseIntegration = BaseIntegration> = {\n  register: RegisterFunction<TIntegration>\n  unregister: UnregisterFunction<TIntegration>\n  handler: WebhookFunction<TIntegration>\n  /**\n   * @deprecated\n   */\n  createUser?: CreateUserFunction<TIntegration>\n  /**\n   * @deprecated\n   */\n  createConversation?: CreateConversationFunction<TIntegration>\n  actions: ActionFunctions<TIntegration>\n  channels: ChannelFunctions<TIntegration>\n}\n\nexport class IntegrationImplementation<TIntegration extends BaseIntegration = BaseIntegration> {\n  public readonly props: IntegrationImplementationProps<TIntegration>\n  public readonly actions: IntegrationImplementationProps<TIntegration>['actions']\n  public readonly channels: IntegrationImplementationProps<TIntegration>['channels']\n  public readonly register: IntegrationImplementationProps<TIntegration>['register']\n  public readonly unregister: IntegrationImplementationProps<TIntegration>['unregister']\n  public readonly createUser: IntegrationImplementationProps<TIntegration>['createUser']\n  public readonly createConversation: IntegrationImplementationProps<TIntegration>['createConversation']\n  public readonly webhook: IntegrationImplementationProps<TIntegration>['handler']\n\n  public constructor(props: IntegrationImplementationProps<TIntegration>) {\n    this.props = props\n    this.actions = props.actions\n    this.channels = props.channels\n    this.register = props.register\n    this.unregister = props.unregister\n    this.createUser = props.createUser\n    this.createConversation = props.createConversation\n    this.webhook = props.handler\n  }\n\n  public readonly handler = integrationHandler<TIntegration>(this)\n  public readonly start = (port?: number): Promise<Server> => serve(this.handler, port)\n}\n", "import * as client from '@botpress/client'\nimport { log } from '../log'\nimport { Request, Response, parseBody } from '../serve'\nimport { BotSpecificClient } from './client'\nimport * as types from './client/types'\nimport { BotContext, extractContext } from './context'\nimport { BaseBot } from './generic'\n\ntype CommonArgs<TBot extends BaseBot> = {\n  ctx: BotContext\n  client: BotSpecificClient<TBot>\n}\n\ntype MessagePayload<TBot extends BaseBot> = {\n  user: client.User\n  conversation: client.Conversation\n  message: types.MessageResponse<TBot>['message']\n  event: client.Event\n  states: {\n    [TState in keyof TBot['states']]: {\n      type: StateType\n      payload: TBot['states'][TState]\n    }\n  }\n}\ntype MessageArgs<TBot extends BaseBot> = CommonArgs<TBot> & MessagePayload<TBot>\n\ntype EventPayload<TBot extends BaseBot> = types.EventResponse<TBot>\ntype EventArgs<TBot extends BaseBot> = CommonArgs<TBot> & EventPayload<TBot>\n\ntype StateExpiredPayload = { state: client.State }\ntype StateExpiredArgs<TBot extends BaseBot> = CommonArgs<TBot> & StateExpiredPayload\n\nexport type StateType = 'conversation' | 'user' | 'bot'\n\nexport type MessageHandler<TBot extends BaseBot> = (args: MessageArgs<TBot>) => Promise<void>\n\nexport type EventHandler<TBot extends BaseBot> = (args: EventArgs<TBot>) => Promise<void>\n\nexport type StateExpiredHandler<TBot extends BaseBot> = (args: StateExpiredArgs<TBot>) => Promise<void>\n\nexport type BotHandlers<TBot extends BaseBot> = {\n  messageHandlers: MessageHandler<TBot>[]\n  eventHandlers: EventHandler<TBot>[]\n  stateExpiredHandlers: StateExpiredHandler<TBot>[]\n}\n\ntype ServerProps<TBot extends BaseBot> = CommonArgs<TBot> & {\n  req: Request\n  instance: BotHandlers<TBot>\n}\n\nexport const botHandler =\n  <TBot extends BaseBot>(instance: BotHandlers<TBot>) =>\n  async (req: Request): Promise<Response | void> => {\n    const ctx = extractContext(req.headers)\n\n    if (ctx.operation !== 'ping') {\n      log.info(`Received ${ctx.operation} operation for bot ${ctx.botId} of type ${ctx.type}`)\n    }\n\n    const botClient = new BotSpecificClient<TBot>(new client.Client({ botId: ctx.botId }))\n\n    const props: ServerProps<TBot> = {\n      req,\n      ctx,\n      client: botClient,\n      instance,\n    }\n\n    switch (ctx.operation) {\n      case 'action_triggered':\n        throw new Error(`Operation ${ctx.operation} not supported yet`)\n      case 'event_received':\n        await onEventReceived<TBot>(props as ServerProps<TBot>)\n        break\n      case 'register':\n        await onRegister<TBot>(props as ServerProps<TBot>)\n        break\n      case 'unregister':\n        await onUnregister<TBot>(props as ServerProps<TBot>)\n        break\n      case 'ping':\n        await onPing<TBot>(props as ServerProps<TBot>)\n        break\n      default:\n        throw new Error(`Unknown operation ${ctx.operation}`)\n    }\n\n    return { status: 200 }\n  }\n\nconst onPing = async <TBot extends BaseBot>(_: ServerProps<TBot>) => {}\nconst onRegister = async <TBot extends BaseBot>(_: ServerProps<TBot>) => {}\nconst onUnregister = async <TBot extends BaseBot>(_: ServerProps<TBot>) => {}\nconst onEventReceived = async <TBot extends BaseBot>({ ctx, req, client, instance }: ServerProps<TBot>) => {\n  log.debug(`Received event ${ctx.type}`)\n\n  const body = parseBody<EventPayload<TBot>>(req)\n  const event = body.event as client.Event\n\n  switch (ctx.type) {\n    case 'message_created':\n      const messagePayload: MessagePayload<TBot> = {\n        user: event.payload.user,\n        conversation: event.payload.conversation,\n        message: event.payload.message,\n        states: event.payload.states,\n        event,\n      }\n\n      await Promise.all(\n        instance.messageHandlers.map((handler) =>\n          handler({\n            client,\n            ctx,\n            ...messagePayload,\n          })\n        )\n      )\n      break\n    case 'state_expired':\n      const statePayload: StateExpiredPayload = { state: event.payload.state }\n      await Promise.all(\n        instance.stateExpiredHandlers.map((handler) =>\n          handler({\n            client,\n            ctx,\n            ...statePayload,\n          })\n        )\n      )\n      break\n    default:\n      const eventPayload = { event: body.event } as EventPayload<TBot>\n      await Promise.all(\n        instance.eventHandlers.map((handler) =>\n          handler({\n            client,\n            ctx,\n            ...eventPayload,\n          })\n        )\n      )\n  }\n}\n", "import { Client } from '@botpress/client'\nimport { BaseBot } from '../generic'\nimport * as routes from './routes'\n\n/**\n * Just like the regular botpress client, but typed with the bot's properties.\n */\nexport class BotSpecificClient<TBot extends BaseBot> {\n  public constructor(private readonly client: Client) {}\n\n  public getConversation: routes.GetConversation<TBot> = (x) => this.client.getConversation(x)\n  public listConversations: routes.ListConversations<TBot> = (x) => this.client.listConversations(x)\n  public updateConversation: routes.UpdateConversation<TBot> = (x) => this.client.updateConversation(x)\n  public deleteConversation: routes.DeleteConversation<TBot> = (x) => this.client.deleteConversation(x)\n\n  public listParticipants: routes.ListParticipants<TBot> = (x) => this.client.listParticipants(x)\n  public addParticipant: routes.AddParticipant<TBot> = (x) => this.client.addParticipant(x)\n  public getParticipant: routes.GetParticipant<TBot> = (x) => this.client.getParticipant(x)\n  public removeParticipant: routes.RemoveParticipant<TBot> = (x) => this.client.removeParticipant(x)\n\n  public getEvent: routes.GetEvent<TBot> = ((x) => this.client.getEvent(x)) as routes.GetEvent<TBot>\n  public listEvents: routes.ListEvents<TBot> = ((x) => this.client.listEvents(x)) as routes.ListEvents<TBot>\n\n  public createMessage: routes.CreateMessage<TBot> = ((x) => this.client.createMessage(x)) as routes.CreateMessage<TBot>\n  public getOrCreateMessage: routes.GetOrCreateMessage<TBot> = ((x) =>\n    this.client.getOrCreateMessage(x)) as routes.GetOrCreateMessage<TBot>\n  public getMessage: routes.GetMessage<TBot> = ((x) => this.client.getMessage(x)) as routes.GetMessage<TBot>\n  public updateMessage: routes.UpdateMessage<TBot> = ((x) => this.client.updateMessage(x)) as routes.UpdateMessage<TBot>\n  public listMessages: routes.ListMessages<TBot> = ((x) => this.client.listMessages(x)) as routes.ListMessages<TBot>\n  public deleteMessage: routes.DeleteMessage<TBot> = ((x) => this.client.deleteMessage(x)) as routes.DeleteMessage<TBot>\n\n  public getUser: routes.GetUser<TBot> = (x) => this.client.getUser(x)\n  public listUsers: routes.ListUsers<TBot> = (x) => this.client.listUsers(x)\n  public updateUser: routes.UpdateUser<TBot> = (x) => this.client.updateUser(x)\n  public deleteUser: routes.DeleteUser<TBot> = (x) => this.client.deleteUser(x)\n\n  public getState: routes.GetState<TBot> = ((x) =>\n    this.client.getState(x).then((y) => ({ state: { ...y.state, payload: y.state.payload } }))) as routes.GetState<TBot>\n  public setState: routes.SetState<TBot> = ((x) =>\n    this.client.setState(x).then((y) => ({ state: { ...y.state, payload: y.state.payload } }))) as routes.SetState<TBot>\n  public getOrSetState: routes.GetOrSetState<TBot> = ((x) =>\n    this.client\n      .getOrSetState(x)\n      .then((y) => ({ state: { ...y.state, payload: y.state.payload } }))) as routes.GetOrSetState<TBot>\n  public patchState: routes.PatchState<TBot> = ((x) =>\n    this.client\n      .patchState(x)\n      .then((y) => ({ state: { ...y.state, payload: y.state.payload } }))) as routes.PatchState<TBot>\n\n  public callAction: routes.CallAction<TBot> = (x) => this.client.callAction(x)\n\n  /**\n   * @deprecated Use `callAction` to delegate the conversation creation to an integration.\n   */\n  public createConversation: routes.CreateConversation<TBot> = (x) => this.client.createConversation(x)\n  /**\n   * @deprecated Use `callAction` to delegate the conversation creation to an integration.\n   */\n  public getOrCreateConversation: routes.GetOrCreateConversation<TBot> = (x) => this.client.getOrCreateConversation(x)\n  /**\n   * @deprecated Use `callAction` to delegate the user creation to an integration.\n   */\n  public createUser: routes.CreateUser<TBot> = (x) => this.client.createUser(x)\n  /**\n   * @deprecated Use `callAction` to delegate the user creation to an integration.\n   */\n  public getOrCreateUser: routes.GetOrCreateUser<TBot> = (x) => this.client.getOrCreateUser(x)\n}\n", "import { z } from 'zod'\nimport { botIdHeader, configurationHeader, operationHeader, typeHeader } from '../const'\n\nexport const botOperationSchema = z.enum(['event_received', 'register', 'unregister', 'ping', 'action_triggered'])\n\nexport type BotOperation = z.infer<typeof botOperationSchema>\n\nexport type BotContext = {\n  botId: string\n  type: string\n  operation: BotOperation\n  configuration: {\n    payload: string\n  }\n}\n\nexport const extractContext = (headers: Record<string, string | undefined>): BotContext => {\n  const botId = headers[botIdHeader]\n  const base64Configuration = headers[configurationHeader]\n  const type = headers[typeHeader]\n  const operation = botOperationSchema.parse(headers[operationHeader])\n\n  if (!botId) {\n    throw new Error('Missing bot headers')\n  }\n\n  if (!type) {\n    throw new Error('Missing type headers')\n  }\n\n  if (!base64Configuration) {\n    throw new Error('Missing configuration headers')\n  }\n\n  if (!operation) {\n    throw new Error('Missing operation headers')\n  }\n\n  return {\n    botId,\n    operation,\n    type,\n    configuration: base64Configuration ? JSON.parse(Buffer.from(base64Configuration, 'base64').toString('utf-8')) : {},\n  }\n}\n", "import type { Server } from 'node:http'\nimport { z } from 'zod'\nimport { SchemaDefinition } from '../schema'\nimport { serve } from '../serve'\nimport { AnyZodObject, Cast } from '../type-utils'\nimport { BaseIntegrations } from './generic'\nimport { IntegrationInstance } from './integration-instance'\nimport { botHandler, MessageHandler, EventHandler, StateExpiredHandler, StateType } from './server'\n\ntype BaseStates = Record<string, AnyZodObject>\ntype BaseEvents = Record<string, AnyZodObject>\n\ntype TagDefinition = {\n  title?: string\n  description?: string\n}\n\ntype StateDefinition<TState extends BaseStates[string]> = SchemaDefinition<TState> & {\n  type: StateType\n  expiry?: number\n}\n\ntype RecurringEventDefinition<TEvents extends BaseEvents> = {\n  [K in keyof TEvents]: {\n    type: K\n    payload: z.infer<TEvents[K]>\n    schedule: { cron: string }\n  }\n}[keyof TEvents]\n\ntype EventDefinition<TEvent extends BaseEvents[string]> = SchemaDefinition<TEvent>\n\ntype ConfigurationDefinition = SchemaDefinition\n\ntype UserDefinition = {\n  tags?: Record<string, TagDefinition>\n}\n\ntype ConversationDefinition = {\n  tags?: Record<string, TagDefinition>\n}\n\ntype MessageDefinition = {\n  tags?: Record<string, TagDefinition>\n}\n\nexport type BotProps<\n  TIntegrations extends BaseIntegrations = BaseIntegrations,\n  TStates extends BaseStates = BaseStates,\n  TEvents extends BaseEvents = BaseEvents\n> = {\n  integrations?: {\n    [K in keyof TIntegrations]?: IntegrationInstance<Cast<K, string>>\n  }\n  user?: UserDefinition\n  conversation?: ConversationDefinition // TODO: add configuration to generic and infer from there\n  message?: MessageDefinition\n  states?: {\n    [K in keyof TStates]: StateDefinition<TStates[K]>\n  }\n  configuration?: ConfigurationDefinition\n  events?: {\n    [K in keyof TEvents]: EventDefinition<TEvents[K]>\n  }\n  recurringEvents?: Record<string, RecurringEventDefinition<TEvents>>\n}\n\ntype BotFrom<TIntegrations extends BaseIntegrations, TStates extends BaseStates, TEvents extends BaseEvents> = {\n  integrations: TIntegrations\n  states: {\n    [K in keyof TStates]: z.infer<TStates[K]>\n  }\n  events: {\n    [K in keyof TEvents]: z.infer<TEvents[K]>\n  }\n}\n\ntype BotState<\n  TIntegrations extends BaseIntegrations = BaseIntegrations,\n  TStates extends BaseStates = BaseStates,\n  TEvents extends BaseEvents = BaseEvents\n> = {\n  messageHandlers: MessageHandler<BotFrom<TIntegrations, TStates, TEvents>>[]\n  eventHandlers: EventHandler<BotFrom<TIntegrations, TStates, TEvents>>[]\n  stateExpiredHandlers: StateExpiredHandler<BotFrom<TIntegrations, TStates, TEvents>>[]\n}\n\nexport class Bot<\n  TIntegrations extends BaseIntegrations = BaseIntegrations,\n  TStates extends BaseStates = BaseStates,\n  TEvents extends BaseEvents = BaseEvents\n> {\n  private _state: BotState<TIntegrations, TStates, TEvents> = {\n    messageHandlers: [],\n    eventHandlers: [],\n    stateExpiredHandlers: [],\n  }\n\n  public readonly props: BotProps<TIntegrations, TStates, TEvents>\n\n  public constructor(props: BotProps<TIntegrations, TStates, TEvents>) {\n    this.props = props\n  }\n\n  public readonly message = (handler: MessageHandler<BotFrom<TIntegrations, TStates, TEvents>>): void => {\n    this._state.messageHandlers.push(handler)\n  }\n  public readonly event = (handler: EventHandler<BotFrom<TIntegrations, TStates, TEvents>>): void => {\n    this._state.eventHandlers.push(handler)\n  }\n  public readonly stateExpired = (handler: StateExpiredHandler<BotFrom<TIntegrations, TStates, TEvents>>): void => {\n    this._state.stateExpiredHandlers.push(handler)\n  }\n\n  public readonly handler = botHandler(this._state)\n  public readonly start = (port?: number): Promise<Server> => serve(this.handler, port)\n}\n"],
  "mappings": "2jBAAA,IAAAA,GAAA,GAAAC,EAAAD,GAAA,SAAAE,EAAA,sBAAAC,EAAA,gBAAAC,EAAA,0BAAAC,EAAA,8BAAAC,EAAA,gBAAAC,EAAA,oBAAAC,EAAA,wBAAAC,EAAA,wBAAAC,EAAA,aAAAC,EAAA,oBAAAC,EAAA,cAAAC,EAAA,UAAAC,EAAA,eAAAC,EAAA,oBAAAC,IAAA,eAAAC,GAAAjB,ICAA,IAAAkB,EAAA,GAAAC,EAAAD,EAAA,cAAAE,KAAA,IAAAC,EAAkB,eAEZC,EAAiB,IAAE,OAAO,EAAE,IAAI,CAAC,EAEjCC,GAAoB,IAAE,OAAO,CACjC,KAAMD,CACR,CAAC,EAEKE,GAAwB,IAAE,OAAO,CACrC,SAAUF,CACZ,CAAC,EAEKG,GAAqB,IAAE,OAAO,CAClC,SAAUH,CACZ,CAAC,EAEKI,GAAqB,IAAE,OAAO,CAClC,SAAUJ,CACZ,CAAC,EAEKK,GAAqB,IAAE,OAAO,CAClC,SAAUL,CACZ,CAAC,EAEKM,GAAoB,IAAE,OAAO,CACjC,QAASN,EACT,MAAOA,EAAe,SAAS,CACjC,CAAC,EAEKO,GAAwB,IAAE,OAAO,CACrC,SAAU,IAAE,OAAO,EACnB,UAAW,IAAE,OAAO,EACpB,QAAS,IAAE,OAAO,EAAE,SAAS,EAC7B,MAAO,IAAE,OAAO,EAAE,SAAS,CAC7B,CAAC,EAEKC,EAAa,IAAE,OAAO,CAC1B,MAAOR,EACP,SAAUA,EAAe,SAAS,EAClC,SAAUA,EAAe,SAAS,EAClC,QAAS,IAAE,MACT,IAAE,OAAO,CACP,OAAQ,IAAE,KAAK,CAAC,WAAY,MAAO,KAAK,CAAC,EACzC,MAAOA,EACP,MAAOA,CACT,CAAC,CACH,CACF,CAAC,EAEKS,EAAe,IAAE,OAAO,CAC5B,KAAMT,EACN,QAAS,IAAE,MACT,IAAE,OAAO,CACP,MAAOA,EACP,MAAOA,CACT,CAAC,CACH,CACF,CAAC,EAEKU,GAAiB,IAAE,OAAO,CAC9B,MAAO,IAAE,MAAMF,CAAU,CAC3B,CAAC,EAEYV,GAAW,CACtB,KAAM,CAAE,OAAQG,EAAkB,EAClC,SAAU,CAAE,OAAQC,EAAsB,EAC1C,MAAO,CAAE,OAAQC,EAAmB,EACpC,MAAO,CAAE,OAAQC,EAAmB,EACpC,MAAO,CAAE,OAAQC,EAAmB,EACpC,KAAM,CAAE,OAAQC,EAAkB,EAClC,SAAU,CAAE,OAAQC,EAAsB,EAC1C,SAAU,CAAE,OAAQG,EAAe,EACnC,KAAM,CAAE,OAAQF,CAAW,EAC3B,SAAU,CAAE,OAAQC,CAAa,EACjC,OAAQ,CAAE,OAAQA,CAAa,CACjC,EC3EO,IAAME,EAAc,WACdC,EAAkB,gBAClBC,EAAsB,mBACtBC,EAAkB,eAElBC,EAAsB,qBACtBC,EAAkB,iBAClBC,EAAa,YCP1B,IAAAC,EAAsD,qBCM/C,IAAMC,EAAc,QDapB,SAASC,EAAaC,EAAiB,CAC5C,GAAI,CAACA,EAAI,KACP,MAAM,IAAI,MAAM,cAAc,EAEhC,OAAO,KAAK,MAAMA,EAAI,IAAI,CAC5B,CAEA,eAAsBC,EACpBC,EACAC,EAAe,KACfC,EAAmCC,GAClB,CAEjB,IAAMC,KAAS,gBAAa,MAAON,EAAKO,IAAQ,CAC9C,GAAI,CACF,IAAMC,EAAU,MAAMC,GAA4BT,CAAG,EACrD,GAAIQ,EAAQ,OAAS,UAAW,CAC9BD,EAAI,UAAU,GAAG,EAAE,IAAI,IAAI,EAC3B,MACF,CACA,IAAMG,EAAW,MAAMR,EAAQM,CAAO,EACtCD,EAAI,UAAUG,GAAU,QAAU,IAAKA,GAAU,SAAW,CAAC,CAAC,EAAE,IAAIA,GAAU,MAAQ,IAAI,CAC5F,OAASC,EAAP,CACAC,EAAI,MAAM,+BAAgC,CAAE,MAAOD,GAAG,SAAW,wBAAyB,CAAC,EAC3FJ,EAAI,UAAU,GAAG,EAAE,IAAI,KAAK,UAAU,CAAE,MAAOI,GAAG,SAAW,wBAAyB,CAAC,CAAC,CAC1F,CACF,CAAC,EAED,OAAAL,EAAO,OAAOH,EAAM,IAAMC,EAASD,CAAI,CAAC,EACjCG,CACT,CAEA,eAAeG,GAA4BI,EAA6C,CACtF,IAAMC,EAAO,MAAMC,GAASF,CAAQ,EAC9BG,EAAU,CAAC,EAEjB,QAASC,EAAI,EAAGA,EAAIJ,EAAS,WAAW,OAAQI,GAAK,EAAG,CACtD,IAAMC,EAAML,EAAS,WAAWI,CAAC,EAAG,YAAY,EAC1CE,EAAQN,EAAS,WAAWI,EAAI,CAAC,EACvCD,EAAQE,CAAG,EAAIC,CACjB,CAEA,IAAMC,EAAM,IAAI,IACdP,EAAS,KAAO,GAChBA,EAAS,QAAQ,KAAO,UAAUA,EAAS,QAAQ,OAAS,uBAC9D,EAEA,MAAO,CACL,KAAAC,EACA,KAAMM,EAAI,SACV,MAAOC,GAAWD,EAAI,OAAQ,GAAG,EACjC,QAAAJ,EACA,OAAQH,EAAS,QAAQ,YAAY,GAAK,KAC5C,CACF,CAEA,SAASQ,GAAWF,EAAeG,EAAgB,CACjD,OAAOH,EAAM,QAAQG,CAAM,IAAM,EAAIH,EAAM,MAAMG,EAAO,MAAM,EAAIH,CACpE,CAEA,eAAeJ,GAASF,EAA2B,CACjD,OAAO,IAAI,QAA4B,CAACU,EAASC,IAAW,CAC1D,GAAIX,EAAS,SAAW,QAAUA,EAAS,SAAW,OAASA,EAAS,SAAW,QACjF,OAAOU,EAAQ,MAAS,EAG1B,IAAIT,EAAO,GAEXD,EAAS,GAAG,OAASY,GAAWX,GAAQW,EAAM,SAAS,CAAE,EACzDZ,EAAS,GAAG,QAAUF,GAAMa,EAAOb,CAAC,CAAC,EACrCE,EAAS,GAAG,MAAO,IAAMU,EAAQT,CAAI,CAAC,CACxC,CAAC,CACH,CAEA,SAAST,GAAgBF,EAAc,CACrCS,EAAI,KAAK,qBAAqBT,GAAM,CACtC,CE/FA,IAAAuB,EAAkB,eAUX,IAAMC,GAA6B,IAAE,KAAK,CAC/C,mBACA,kBACA,mBACA,WACA,aACA,OACA,cACA,qBACF,CAAC,EAaYC,EAAkBC,GAAoE,CACjG,IAAMC,EAAQD,EAAQE,CAAW,EAC3BC,EAAYH,EAAQI,CAAe,EACnCC,EAAgBL,EAAQM,CAAmB,EAC3CC,EAAYP,EAAQQ,CAAe,EACnCC,EAAsBT,EAAQU,CAAmB,EACjDC,EAAYb,GAA2B,MAAME,EAAQY,CAAe,CAAC,EAE3E,GAAI,CAACX,EACH,MAAM,IAAI,MAAM,qBAAqB,EAGvC,GAAI,CAACE,EACH,MAAM,IAAI,MAAM,0BAA0B,EAG5C,GAAI,CAACE,EACH,MAAM,IAAI,MAAM,6BAA6B,EAG/C,GAAI,CAACE,EACH,MAAM,IAAI,MAAM,yBAAyB,EAG3C,GAAI,CAACE,EACH,MAAM,IAAI,MAAM,+BAA+B,EAGjD,GAAI,CAACE,EACH,MAAM,IAAI,MAAM,2BAA2B,EAG7C,MAAO,CACL,MAAAV,EACA,UAAAE,EACA,cAAAE,EACA,UAAAE,EACA,UAAAI,EACA,cAAeF,EAAsB,KAAK,MAAM,OAAO,KAAKA,EAAqB,QAAQ,EAAE,SAAS,OAAO,CAAC,EAAI,CAAC,CACnH,CACF,ECqDO,IAAMI,EAAN,KAOL,CAiBO,YACWC,EAChB,CADgB,WAAAA,EAEhB,KAAK,KAAOA,EAAM,KAClB,KAAK,QAAUA,EAAM,QACrB,KAAK,KAAOA,EAAM,KAClB,KAAK,OAASA,EAAM,OACpB,KAAK,MAAQA,EAAM,MACnB,KAAK,WAAaA,EAAM,WACxB,KAAK,YAAcA,EAAM,YACzB,KAAK,cAAgBA,EAAM,cAC3B,KAAK,OAASA,EAAM,OACpB,KAAK,QAAUA,EAAM,QACrB,KAAK,SAAWA,EAAM,SACtB,KAAK,OAASA,EAAM,OACpB,KAAK,KAAOA,EAAM,KAClB,KAAK,QAAUA,EAAM,QACrB,KAAK,SAAWA,EAAM,QACxB,CAlCgB,KACA,QACA,MACA,YACA,KACA,OACA,cACA,OACA,QACA,SACA,OACA,KACA,QACA,WACA,QAqBlB,ECxKA,IAAAC,EAAiF,4BCO1E,IAAMC,EAAN,KAAsE,CACpE,YAA6BC,EAAgB,CAAhB,YAAAA,CAAiB,CAE9C,mBAAgEC,GACrE,KAAK,OAAO,mBAAmBA,CAAC,EAC3B,gBAA0DA,GAC/D,KAAK,OAAO,gBAAgBA,CAAC,EACxB,kBAA8DA,GACnE,KAAK,OAAO,kBAAkBA,CAAC,EAC1B,wBAA0EA,GAC/E,KAAK,OAAO,wBAAwBA,CAAC,EAChC,mBAAgEA,GACrE,KAAK,OAAO,mBAAmBA,CAAC,EAC3B,mBAAgEA,GACrE,KAAK,OAAO,mBAAmBA,CAAC,EAE3B,iBAA4DA,GACjE,KAAK,OAAO,iBAAiBA,CAAC,EACzB,eAAwDA,GAC7D,KAAK,OAAO,eAAeA,CAAC,EACvB,eAAwDA,GAC7D,KAAK,OAAO,eAAeA,CAAC,EACvB,kBAA8DA,GACnE,KAAK,OAAO,kBAAkBA,CAAC,EAE1B,YAAkDA,GACvD,KAAK,OAAO,YAAYA,CAAC,EACpB,SAA4CA,GAAM,KAAK,OAAO,SAASA,CAAC,EACxE,WAAgDA,GACrD,KAAK,OAAO,WAAWA,CAAC,EAEnB,cAAsDA,GAC3D,KAAK,OAAO,cAAcA,CAAC,EACtB,mBAAgEA,GACrE,KAAK,OAAO,mBAAmBA,CAAC,EAC3B,WAAgDA,GACrD,KAAK,OAAO,WAAWA,CAAC,EACnB,cAAsDA,GAC3D,KAAK,OAAO,cAAcA,CAAC,EACtB,aAAoDA,GACzD,KAAK,OAAO,aAAaA,CAAC,EACrB,cAAsDA,GAC3D,KAAK,OAAO,cAAcA,CAAC,EAEtB,WAAgDA,GACrD,KAAK,OAAO,WAAWA,CAAC,EACnB,QAA0CA,GAAM,KAAK,OAAO,QAAQA,CAAC,EACrE,UAA6CA,GAAM,KAAK,OAAO,UAAUA,CAAC,EAC1E,gBAA0DA,GAC/D,KAAK,OAAO,gBAAgBA,CAAC,EACxB,WAAgDA,GACrD,KAAK,OAAO,WAAWA,CAAC,EACnB,WAA+CA,GAAM,KAAK,OAAO,WAAWA,CAAC,EAE7E,SAA4CA,GAAM,KAAK,OAAO,SAASA,CAAC,EACxE,SAA4CA,GAAM,KAAK,OAAO,SAASA,CAAC,EACxE,cAAsDA,GAC3D,KAAK,OAAO,cAAcA,CAAC,EACtB,WAAgDA,GACrD,KAAK,OAAO,WAAWA,CAAC,EAEnB,qBAAmEA,GAAM,KAAK,OAAO,qBAAqBA,CAAC,CACpH,ECpEA,IAAAC,EAAiB,mBAEXC,EAA0BC,GAAyC,CACvE,GAAI,QAAQ,IAAI,gBAAqB,OACnC,OAAO,KAAK,UAAU,CAAE,IAAK,EAAAC,QAAK,OAAO,GAAGD,CAAI,EAAG,qBAAsB,EAAK,CAAC,EAC1E,CACL,GAAM,CAACE,EAAQ,GAAGC,CAAK,EAAIH,EAC3B,OAAO,EAAAC,QAAK,OAAO,mBAAmBC,IAAU,GAAGC,CAAK,CAC1D,CACF,EAEaC,EAAoB,CAI/B,OAAQ,KACC,CACL,KAAM,IAAIJ,IAA0C,CAClD,QAAQ,KAAKD,EAAuBC,CAAI,CAAC,CAC3C,EACA,KAAM,IAAIA,IAA0C,CAClD,QAAQ,KAAKD,EAAuBC,CAAI,CAAC,CAC3C,EACA,MAAO,IAAIA,IAA2C,CACpD,QAAQ,MAAMD,EAAuBC,CAAI,CAAC,CAC5C,EACA,MAAO,IAAIA,IAA2C,CACpD,QAAQ,MAAMD,EAAuBC,CAAI,CAAC,CAC5C,CACF,EAEJ,EFqGO,IAAMK,EAC4BC,GACvC,MAAOC,GAA2C,CAChD,IAAMC,EAAMC,EAAeF,EAAI,OAAO,EAEhCG,EAAS,IAAIC,EACjB,IAAI,SAAO,CAAE,MAAOH,EAAI,MAAO,cAAeA,EAAI,aAAc,CAAC,CACnE,EAEMI,EAAQ,CACZ,IAAAJ,EACA,IAAAD,EACA,OAAAG,EACA,OAAQG,EACR,SAAAP,CACF,EAEA,GAAI,CACF,IAAIQ,EACJ,OAAQN,EAAI,UAAW,CACrB,IAAK,mBACHM,EAAW,MAAMC,GAAwBH,CAAK,EAC9C,MACF,IAAK,WACHE,EAAW,MAAME,GAAyBJ,CAAK,EAC/C,MACF,IAAK,aACHE,EAAW,MAAMG,GAA2BL,CAAK,EACjD,MACF,IAAK,kBACHE,EAAW,MAAMI,GAA+BN,CAAK,EACrD,MACF,IAAK,mBACHE,EAAW,MAAMK,GAAgCP,CAAK,EACtD,MACF,IAAK,OACHE,EAAW,MAAMM,GAAqBR,CAAK,EAC3C,MACF,IAAK,cACHE,EAAW,MAAMO,GAA2BT,CAAK,EACjD,MACF,IAAK,sBACHE,EAAW,MAAMQ,GAAmCV,CAAK,EACzD,MACF,QACE,MAAM,IAAI,MAAM,qBAAqBJ,EAAI,WAAW,CACxD,CACA,OAAOM,EAAW,CAAE,GAAGA,EAAU,OAAQA,EAAS,QAAU,GAAI,EAAI,CAAE,OAAQ,GAAI,CACpF,OAASS,EAAP,CACA,GAAIA,aAAa,eACf,MAAO,CAAE,OAAQA,EAAE,KAAM,KAAM,KAAK,UAAUA,EAAE,OAAO,CAAC,CAAE,EAE1D,MAAMA,CAEV,CACF,EAEIH,GAAS,MAA6CI,GAAiC,CAAC,EAExFT,GAAY,MAA6C,CAC7D,OAAAL,EACA,IAAAF,EACA,IAAKiB,EACL,OAAAC,EACA,SAAApB,CACF,IAAiC,CAC/B,GAAM,CAAE,IAAAC,CAAI,EAAIoB,EAA0BF,CAAe,EACzD,OAAOnB,EAAS,QAAQ,CAAE,OAAAI,EAAQ,IAAAF,EAAK,IAAAD,EAAK,OAAAmB,CAAO,CAAC,CACtD,EAEMV,GAAa,MAA6C,CAC9D,OAAAN,EACA,IAAAF,EACA,IAAAD,EACA,OAAAmB,EACA,SAAApB,CACF,IAAiC,CAC/B,GAAI,CAACA,EAAS,SACZ,OAEF,GAAM,CAAE,WAAAsB,CAAW,EAAID,EAA2BpB,CAAG,EACrD,MAAMD,EAAS,SAAS,CAAE,OAAAI,EAAQ,IAAAF,EAAK,WAAAoB,EAAY,OAAAF,CAAO,CAAC,CAC7D,EAEMT,GAAe,MAA6C,CAChE,OAAAP,EACA,IAAAF,EACA,IAAAD,EACA,OAAAmB,EACA,SAAApB,CACF,IAAiC,CAC/B,GAAI,CAACA,EAAS,WACZ,OAEF,GAAM,CAAE,WAAAsB,CAAW,EAAID,EAA6BpB,CAAG,EACvD,MAAMD,EAAS,WAAW,CAAE,IAAAE,EAAK,WAAAoB,EAAY,OAAAlB,EAAQ,OAAAgB,CAAO,CAAC,CAC/D,EAEML,GAAe,MAA6C,CAChE,OAAAX,EACA,IAAAF,EACA,IAAAD,EACA,OAAAmB,EACA,SAAApB,CACF,IAAiC,CAC/B,GAAI,CAACA,EAAS,WACZ,OAEF,GAAM,CAAE,KAAAuB,CAAK,EAAIF,EAA2CpB,CAAG,EAC/D,OAAO,MAAMD,EAAS,WAAW,CAAE,IAAAE,EAAK,OAAAE,EAAQ,KAAAmB,EAAM,OAAAH,CAAO,CAAC,CAChE,EAEMJ,GAAuB,MAA6C,CACxE,OAAAZ,EACA,IAAAF,EACA,IAAAD,EACA,OAAAmB,EACA,SAAApB,CACF,IAAiC,CAC/B,GAAI,CAACA,EAAS,mBACZ,OAEF,GAAM,CAAE,QAAAwB,EAAS,KAAAD,CAAK,EAAIF,EAAmDpB,CAAG,EAChF,OAAO,MAAMD,EAAS,mBAAmB,CAAE,IAAAE,EAAK,OAAAE,EAAQ,QAAAoB,EAAS,KAAAD,EAAM,OAAAH,CAAO,CAAC,CACjF,EAEMR,GAAmB,MAA6C,CACpE,IAAAV,EACA,IAAAD,EACA,OAAAG,EACA,OAAAgB,EACA,SAAApB,CACF,IAAiC,CAC/B,GAAM,CAAE,aAAAyB,EAAc,KAAAC,EAAM,KAAAC,EAAM,QAAAC,EAAS,QAAAC,CAAQ,EAAIR,EAAwDpB,CAAG,EAE5G6B,EAAiB9B,EAAS,SAASyB,EAAa,OAAO,EAE7D,GAAI,CAACK,EACH,MAAM,IAAI,MAAM,WAAWL,EAAa,mBAAmB,EAG7D,IAAMM,EAAiBD,EAAe,SAASH,CAAI,EAEnD,GAAI,CAACI,EACH,MAAM,IAAI,MAAM,mBAAmBJ,0BAA6BF,EAAa,SAAS,EAUxF,MAAMM,EAAe,CAAE,IAAA7B,EAAK,aAAAuB,EAAc,QAAAI,EAAS,KAAAH,EAAM,KAAAC,EAAM,OAAAvB,EAAQ,QAAAwB,EAAS,IAPpE,MAAO,CAAE,KAAAL,CAAK,IAAwC,CAChE,MAAMnB,EAAO,cAAc,CACzB,GAAIyB,EAAQ,GACZ,KAAMN,CACR,CAAC,CACH,EAEqF,OAAAH,CAAO,CAAC,CAC/F,EAEMP,GAAoB,MAA6C,CACrE,IAAAZ,EACA,IAAAC,EACA,OAAAE,EACA,OAAAgB,EACA,SAAApB,CACF,IAAiC,CAC/B,GAAM,CAAE,MAAAgC,EAAO,KAAAL,CAAK,EAAIN,EAAsCpB,CAAG,EAEjE,GAAI,CAAC0B,EACH,MAAM,IAAI,MAAM,qBAAqB,EAGvC,IAAMM,EAASjC,EAAS,QAAQ2B,CAAI,EAEpC,GAAI,CAACM,EACH,MAAM,IAAI,MAAM,UAAUN,aAAgB,EAG5C,IAAMO,EAAS,MAAMD,EAAO,CAAE,IAAA/B,EAAK,MAAA8B,EAAO,OAAA5B,EAAQ,KAAAuB,EAAM,OAAAP,CAAO,CAAC,EAEhE,MAAO,CACL,KAAM,KAAK,UAAU,CAAE,OAAAc,CAAO,CAAC,CACjC,CACF,EG5RO,IAAMC,EAAN,KAAwF,CAC7E,MACA,QACA,SACA,SACA,WACA,WACA,mBACA,QAET,YAAYC,EAAqD,CACtE,KAAK,MAAQA,EACb,KAAK,QAAUA,EAAM,QACrB,KAAK,SAAWA,EAAM,SACtB,KAAK,SAAWA,EAAM,SACtB,KAAK,WAAaA,EAAM,WACxB,KAAK,WAAaA,EAAM,WACxB,KAAK,mBAAqBA,EAAM,mBAChC,KAAK,QAAUA,EAAM,OACvB,CAEgB,QAAUC,EAAiC,IAAI,EAC/C,MAASC,GAAmCC,EAAM,KAAK,QAASD,CAAI,CACtF,ECrDA,IAAAE,EAAwB,+BCOjB,IAAMC,EAAN,KAA8C,CAC5C,YAA6BC,EAAgB,CAAhB,YAAAA,CAAiB,CAE9C,gBAAiDC,GAAM,KAAK,OAAO,gBAAgBA,CAAC,EACpF,kBAAqDA,GAAM,KAAK,OAAO,kBAAkBA,CAAC,EAC1F,mBAAuDA,GAAM,KAAK,OAAO,mBAAmBA,CAAC,EAC7F,mBAAuDA,GAAM,KAAK,OAAO,mBAAmBA,CAAC,EAE7F,iBAAmDA,GAAM,KAAK,OAAO,iBAAiBA,CAAC,EACvF,eAA+CA,GAAM,KAAK,OAAO,eAAeA,CAAC,EACjF,eAA+CA,GAAM,KAAK,OAAO,eAAeA,CAAC,EACjF,kBAAqDA,GAAM,KAAK,OAAO,kBAAkBA,CAAC,EAE1F,SAAoCA,GAAM,KAAK,OAAO,SAASA,CAAC,EAChE,WAAwCA,GAAM,KAAK,OAAO,WAAWA,CAAC,EAEtE,cAA8CA,GAAM,KAAK,OAAO,cAAcA,CAAC,EAC/E,mBAAwDA,GAC7D,KAAK,OAAO,mBAAmBA,CAAC,EAC3B,WAAwCA,GAAM,KAAK,OAAO,WAAWA,CAAC,EACtE,cAA8CA,GAAM,KAAK,OAAO,cAAcA,CAAC,EAC/E,aAA4CA,GAAM,KAAK,OAAO,aAAaA,CAAC,EAC5E,cAA8CA,GAAM,KAAK,OAAO,cAAcA,CAAC,EAE/E,QAAiCA,GAAM,KAAK,OAAO,QAAQA,CAAC,EAC5D,UAAqCA,GAAM,KAAK,OAAO,UAAUA,CAAC,EAClE,WAAuCA,GAAM,KAAK,OAAO,WAAWA,CAAC,EACrE,WAAuCA,GAAM,KAAK,OAAO,WAAWA,CAAC,EAErE,SAAoCA,GACzC,KAAK,OAAO,SAASA,CAAC,EAAE,KAAMC,IAAO,CAAE,MAAO,CAAE,GAAGA,EAAE,MAAO,QAASA,EAAE,MAAM,OAAQ,CAAE,EAAE,EACpF,SAAoCD,GACzC,KAAK,OAAO,SAASA,CAAC,EAAE,KAAMC,IAAO,CAAE,MAAO,CAAE,GAAGA,EAAE,MAAO,QAASA,EAAE,MAAM,OAAQ,CAAE,EAAE,EACpF,cAA8CD,GACnD,KAAK,OACF,cAAcA,CAAC,EACf,KAAMC,IAAO,CAAE,MAAO,CAAE,GAAGA,EAAE,MAAO,QAASA,EAAE,MAAM,OAAQ,CAAE,EAAE,EAC/D,WAAwCD,GAC7C,KAAK,OACF,WAAWA,CAAC,EACZ,KAAMC,IAAO,CAAE,MAAO,CAAE,GAAGA,EAAE,MAAO,QAASA,EAAE,MAAM,OAAQ,CAAE,EAAE,EAE/D,WAAuCD,GAAM,KAAK,OAAO,WAAWA,CAAC,EAKrE,mBAAuDA,GAAM,KAAK,OAAO,mBAAmBA,CAAC,EAI7F,wBAAiEA,GAAM,KAAK,OAAO,wBAAwBA,CAAC,EAI5G,WAAuCA,GAAM,KAAK,OAAO,WAAWA,CAAC,EAIrE,gBAAiDA,GAAM,KAAK,OAAO,gBAAgBA,CAAC,CAC7F,ECnEA,IAAAE,EAAkB,eAGX,IAAMC,GAAqB,IAAE,KAAK,CAAC,iBAAkB,WAAY,aAAc,OAAQ,kBAAkB,CAAC,EAapGC,EAAkBC,GAA4D,CACzF,IAAMC,EAAQD,EAAQE,CAAW,EAC3BC,EAAsBH,EAAQI,CAAmB,EACjDC,EAAOL,EAAQM,CAAU,EACzBC,EAAYT,GAAmB,MAAME,EAAQQ,CAAe,CAAC,EAEnE,GAAI,CAACP,EACH,MAAM,IAAI,MAAM,qBAAqB,EAGvC,GAAI,CAACI,EACH,MAAM,IAAI,MAAM,sBAAsB,EAGxC,GAAI,CAACF,EACH,MAAM,IAAI,MAAM,+BAA+B,EAGjD,GAAI,CAACI,EACH,MAAM,IAAI,MAAM,2BAA2B,EAG7C,MAAO,CACL,MAAAN,EACA,UAAAM,EACA,KAAAF,EACA,cAAeF,EAAsB,KAAK,MAAM,OAAO,KAAKA,EAAqB,QAAQ,EAAE,SAAS,OAAO,CAAC,EAAI,CAAC,CACnH,CACF,EFQO,IAAMM,EACYC,GACvB,MAAOC,GAA2C,CAChD,IAAMC,EAAMC,EAAeF,EAAI,OAAO,EAElCC,EAAI,YAAc,QACpBE,EAAI,KAAK,YAAYF,EAAI,+BAA+BA,EAAI,iBAAiBA,EAAI,MAAM,EAGzF,IAAMG,EAAY,IAAIC,EAAwB,IAAW,SAAO,CAAE,MAAOJ,EAAI,KAAM,CAAC,CAAC,EAE/EK,EAA2B,CAC/B,IAAAN,EACA,IAAAC,EACA,OAAQG,EACR,SAAAL,CACF,EAEA,OAAQE,EAAI,UAAW,CACrB,IAAK,mBACH,MAAM,IAAI,MAAM,aAAaA,EAAI,6BAA6B,EAChE,IAAK,iBACH,MAAMM,GAAsBD,CAA0B,EACtD,MACF,IAAK,WACH,MAAME,GAAiBF,CAA0B,EACjD,MACF,IAAK,aACH,MAAMG,GAAmBH,CAA0B,EACnD,MACF,IAAK,OACH,MAAMI,GAAaJ,CAA0B,EAC7C,MACF,QACE,MAAM,IAAI,MAAM,qBAAqBL,EAAI,WAAW,CACxD,CAEA,MAAO,CAAE,OAAQ,GAAI,CACvB,EAEIS,GAAS,MAA6BC,GAAyB,CAAC,EAChEH,GAAa,MAA6BG,GAAyB,CAAC,EACpEF,GAAe,MAA6BE,GAAyB,CAAC,EACtEJ,GAAkB,MAA6B,CAAE,IAAAN,EAAK,IAAAD,EAAK,OAAAY,EAAQ,SAAAb,CAAS,IAAyB,CACzGI,EAAI,MAAM,kBAAkBF,EAAI,MAAM,EAEtC,IAAMY,EAAOC,EAA8Bd,CAAG,EACxCe,EAAQF,EAAK,MAEnB,OAAQZ,EAAI,KAAM,CAChB,IAAK,kBACH,IAAMe,EAAuC,CAC3C,KAAMD,EAAM,QAAQ,KACpB,aAAcA,EAAM,QAAQ,aAC5B,QAASA,EAAM,QAAQ,QACvB,OAAQA,EAAM,QAAQ,OACtB,MAAAA,CACF,EAEA,MAAM,QAAQ,IACZhB,EAAS,gBAAgB,IAAKkB,GAC5BA,EAAQ,CACN,OAAAL,EACA,IAAAX,EACA,GAAGe,CACL,CAAC,CACH,CACF,EACA,MACF,IAAK,gBACH,IAAME,EAAoC,CAAE,MAAOH,EAAM,QAAQ,KAAM,EACvE,MAAM,QAAQ,IACZhB,EAAS,qBAAqB,IAAKkB,GACjCA,EAAQ,CACN,OAAAL,EACA,IAAAX,EACA,GAAGiB,CACL,CAAC,CACH,CACF,EACA,MACF,QACE,IAAMC,EAAe,CAAE,MAAON,EAAK,KAAM,EACzC,MAAM,QAAQ,IACZd,EAAS,cAAc,IAAKkB,GAC1BA,EAAQ,CACN,OAAAL,EACA,IAAAX,EACA,GAAGkB,CACL,CAAC,CACH,CACF,CACJ,CACF,EG1DO,IAAMC,EAAN,KAIL,CACQ,OAAoD,CAC1D,gBAAiB,CAAC,EAClB,cAAe,CAAC,EAChB,qBAAsB,CAAC,CACzB,EAEgB,MAET,YAAYC,EAAkD,CACnE,KAAK,MAAQA,CACf,CAEgB,QAAWC,GAA4E,CACrG,KAAK,OAAO,gBAAgB,KAAKA,CAAO,CAC1C,EACgB,MAASA,GAA0E,CACjG,KAAK,OAAO,cAAc,KAAKA,CAAO,CACxC,EACgB,aAAgBA,GAAiF,CAC/G,KAAK,OAAO,qBAAqB,KAAKA,CAAO,CAC/C,EAEgB,QAAUC,EAAW,KAAK,MAAM,EAChC,MAASC,GAAmCC,EAAM,KAAK,QAASD,CAAI,CACtF",
  "names": ["src_exports", "__export", "Bot", "BotSpecificClient", "IntegrationImplementation", "IntegrationDefinition", "IntegrationSpecificClient", "botIdHeader", "botUserIdHeader", "configurationHeader", "integrationIdHeader", "message_exports", "operationHeader", "parseBody", "serve", "typeHeader", "webhookIdHeader", "__toCommonJS", "message_exports", "__export", "defaults", "import_zod", "NonEmptyString", "textMessageSchema", "markdownMessageSchema", "imageMessageSchema", "audioMessageSchema", "videoMessageSchema", "fileMessageSchema", "locationMessageSchema", "cardSchema", "choiceSchema", "carouselSchema", "botIdHeader", "botUserIdHeader", "integrationIdHeader", "webhookIdHeader", "configurationHeader", "operationHeader", "typeHeader", "import_node_http", "log", "parseBody", "req", "serve", "handler", "port", "callback", "defaultCallback", "server", "res", "request", "mapIncomingMessageToRequest", "response", "e", "log", "incoming", "body", "readBody", "headers", "i", "key", "value", "url", "trimPrefix", "prefix", "resolve", "reject", "chunk", "import_zod", "integrationOperationSchema", "extractContext", "headers", "botId", "botIdHeader", "botUserId", "botUserIdHeader", "integrationId", "integrationIdHeader", "webhookId", "webhookIdHeader", "base64Configuration", "configurationHeader", "operation", "operationHeader", "IntegrationDefinition", "props", "import_client", "IntegrationSpecificClient", "client", "x", "import_util", "serializeForBotMessage", "args", "util", "format", "param", "integrationLogger", "integrationHandler", "instance", "req", "ctx", "extractContext", "client", "IntegrationSpecificClient", "props", "integrationLogger", "response", "onWebhook", "onRegister", "onUnregister", "onMessageCreated", "onActionTriggered", "onPing", "onCreateUser", "onCreateConversation", "e", "_", "incomingRequest", "logger", "parseBody", "webhookUrl", "tags", "channel", "conversation", "user", "type", "payload", "message", "channelHandler", "messageHandler", "input", "action", "output", "IntegrationImplementation", "props", "integrationHandler", "port", "serve", "client", "BotSpecificClient", "client", "x", "y", "import_zod", "botOperationSchema", "extractContext", "headers", "botId", "botIdHeader", "base64Configuration", "configurationHeader", "type", "typeHeader", "operation", "operationHeader", "botHandler", "instance", "req", "ctx", "extractContext", "log", "botClient", "BotSpecificClient", "props", "onEventReceived", "onRegister", "onUnregister", "onPing", "_", "client", "body", "parseBody", "event", "messagePayload", "handler", "statePayload", "eventPayload", "Bot", "props", "handler", "botHandler", "port", "serve"]
}
