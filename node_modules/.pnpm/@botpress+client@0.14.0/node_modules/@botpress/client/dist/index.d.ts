/// <reference types="node" />
/// <reference types="node" />
import { Readable } from 'stream';
import { ClientProps, ClientConfig } from './config';
import { CreateFileResponse } from './gen';
import { ApiClient as AutoGeneratedClient } from './gen/client';
export { isApiError } from './gen/errors';
export * as axios from 'axios';
export type { Message, Conversation, User, State, Event, ModelFile as File, Bot, Integration, Issue, IssueEvent, Account, Workspace, Usage, } from './gen';
export * from './gen/errors';
type CreateFileProps = {
    /**
     * The name of the file.
     */
    name: string;
    /**
     * The data to be uploaded.
     */
    data: Blob | Buffer | Readable;
    /**
     * Set to a value of "true" to index the file in vector storage. Only PDFs, Office documents, and text-based files are currently supported. Note that if a file is indexed, it will count towards the Vector Storage quota of the workspace rather than the File Storage quota.
     * @default false
     */
    index?: boolean;
    /**
     * Tags to associate with the file.
     */
    tags?: {
        [key: string]: string;
    };
    /**
     * File content type. If omitted, the content type will be inferred from the file extension. If a type cannot be inferred, the default is "application/octet-stream".
     */
    contentType?: string;
    contentLength?: number;
    /**
     * File access policies. Add "public_content" to allow public access to the file content. Add "integrations" to allo read, search and list operations for any integration installed in the bot.
     */
    accessPolicies?: ('integrations' | 'public_content')[];
};
export declare class Client extends AutoGeneratedClient {
    readonly config: Readonly<ClientConfig>;
    private readonly axiosClient;
    constructor(clientProps?: ClientProps);
    createFile: ({ name, data, index, tags, contentType, contentLength, accessPolicies, }: CreateFileProps) => Promise<CreateFileResponse>;
}
type Simplify<T> = {
    [KeyType in keyof T]: Simplify<T[KeyType]>;
} & {};
type PickMatching<T, V> = {
    [K in keyof T as T[K] extends V ? K : never]: T[K];
};
type ExtractMethods<T> = PickMatching<T, (...rest: any[]) => any>;
type FunctionNames = keyof ExtractMethods<Client>;
export type ClientParams<T extends FunctionNames> = Simplify<Parameters<Client[T]>[0]>;
export type ClientReturn<T extends FunctionNames> = Simplify<Awaited<ReturnType<Client[T]>>>;
